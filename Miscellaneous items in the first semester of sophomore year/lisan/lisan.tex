% 若编译失败，且生成 .synctex(busy) 辅助文件，可能有两个原因：
% 1. 需要插入的图片不存在：Ctrl + F 搜索 'figure' 将这些代码注释/删除掉即可
% 2. 路径/文件名含中文或空格：更改路径/文件名即可

% ------------------------------------------------------------- %
% >> ------------------ 文章宏包及相关设置 ------------------ << %
% 设定文章类型与编码格式
\documentclass[UTF8]{report}		

% 本文特殊宏包
    \usepackage{siunitx} % 埃米单位

% 本文的特殊宏定义
\def\Im{\mathrm{\,Im\,}}
\def\Re{\mathrm{\,Re\,}}
\def\Ln{\mathrm{\,Ln\,}}
\def\Arg{\mathrm{\,Arg\,}}
\def\Arccos{\mathrm{\,Arccos\,}}
\def\Arcsin{\mathrm{\,Arcsin\,}}
\def\Arctan{\mathrm{\,Arctan\,}}

% 通用宏定义
\def\N{\mathbb{N}}
\def\F{\mathbb{F}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\R{\mathbb{R}}
\def\C{\mathbb{C}}
\def\T{\mathbb{T}}
\def\S{\mathbb{S}}
\def\A{\mathbb{A}}
\def\I{\mathscr{I}}
\def\d{\mathrm{d}}
\def\p{\partial}


% 导入基本宏包
    \usepackage[UTF8]{ctex}     % 设置文档为中文语言
    \usepackage[colorlinks, linkcolor=blue, anchorcolor=blue, citecolor=blue, urlcolor=blue]{hyperref}  % 宏包：自动生成超链接 (此宏包与标题中的数学环境冲突)
    % \usepackage{docmute}    % 宏包：子文件导入时自动去除导言区，用于主/子文件的写作方式，\include{./51单片机笔记}即可。注：启用此宏包会导致.tex文件capacity受限。
    \usepackage{amsmath}    % 宏包：数学公式
    \usepackage{mathrsfs}   % 宏包：提供更多数学符号
    \usepackage{amssymb}    % 宏包：提供更多数学符号
    \usepackage{pifont}     % 宏包：提供了特殊符号和字体
    \usepackage{extarrows}  % 宏包：更多箭头符号
    \usepackage{multicol}   % 宏包：支持多栏 
    \usepackage{graphicx}   % 宏包：插入图片
    \usepackage{float}      % 宏包：设置图片浮动位置
    %\usepackage{article}    % 宏包：使文本排版更加优美
    \usepackage{tikz}       % 宏包：绘图工具
    %\usepackage{pgfplots}   % 宏包：绘图工具

% 文章页面margin设置
    \usepackage[a4paper]{geometry}
        \geometry{top=1in}  % 1 inch= 2.46 cm, 0.75 inch = 1.85 cm
        \geometry{bottom=1in}
        \geometry{left=0.75in}
        \geometry{right=0.75in}   % 设置上下左右页边距
        \geometry{marginparwidth=1.75cm}    % 设置边注距离（注释、标记等）

% 配置数学环境
    \usepackage{amsthm} % 宏包：数学环境配置
    % theorem-line 环境自定义
        \newtheoremstyle{MyLineTheoremStyle}% <name>
            {11pt}% <space above>
            {11pt}% <space below>
            {}% <body font> 使用默认正文字体
            {}% <indent amount>
            {\bfseries}% <theorem head font> 设置标题项为加粗
            {：}% <punctuation after theorem head>
            {.5em}% <space after theorem head>
            {\textbf{#1}\thmnumber{#2}\ \ (\,\textbf{#3}\,)}% 设置标题内容顺序
        \theoremstyle{MyLineTheoremStyle} % 应用自定义的定理样式
        \newtheorem{LineTheorem}{Theorem.\,}
    % theorem-block 环境自定义
        \newtheoremstyle{MyBlockTheoremStyle}% <name>
            {11pt}% <space above>
            {11pt}% <space below>
            {}% <body font> 使用默认正文字体
            {}% <indent amount>
            {\bfseries}% <theorem head font> 设置标题项为加粗
            {：\\ \indent}% <punctuation after theorem head>
            {.5em}% <space after theorem head>
            {\textbf{#1}\thmnumber{#2}\ \ (\,\textbf{#3}\,)}% 设置标题内容顺序
        \theoremstyle{MyBlockTheoremStyle} % 应用自定义的定理样式
        \newtheorem{BlockTheorem}[LineTheorem]{Theorem.\,} % 使用 LineTheorem 的计数器
    % definition 环境自定义
        \newtheoremstyle{MySubsubsectionStyle}% <name>
            {11pt}% <space above>
            {11pt}% <space below>
            {}% <body font> 使用默认正文字体
            {}% <indent amount>
            {\bfseries}% <theorem head font> 设置标题项为加粗
            { \indent}% <punctuation after theorem head>
            {0pt}% <space after theorem head>
            {\textbf{#3}}% 设置标题内容顺序
        \theoremstyle{MySubsubsectionStyle} % 应用自定义的定理样式
        \newtheorem{definition}{}

%宏包：有色文本框（proof环境）及其设置
    \usepackage[dvipsnames,svgnames]{xcolor}    %设置插入的文本框颜色
    \usepackage[strict]{changepage}     % 提供一个 adjustwidth 环境
    \usepackage{framed}     % 实现方框效果
        \definecolor{graybox_color}{rgb}{0.95,0.95,0.96} % 文本框颜色。修改此行中的 rgb 数值即可改变方框纹颜色，具体颜色的rgb数值可以在网站https://colordrop.io/ 中获得。（截止目前的尝试还没有成功过，感觉单位不一样）（找到喜欢的颜色，点击下方的小眼睛，找到rgb值，复制修改即可）
        \newenvironment{graybox}{%
        \def\FrameCommand{%
        \hspace{1pt}%
        {\color{gray}\small \vrule width 2pt}%
        {\color{graybox_color}\vrule width 4pt}%
        \colorbox{graybox_color}%
        }%
        \MakeFramed{\advance\hsize-\width\FrameRestore}%
        \noindent\hspace{-4.55pt}% disable indenting first paragraph
        \begin{adjustwidth}{}{7pt}%
        \vspace{2pt}\vspace{2pt}%
        }
        {%
        \vspace{2pt}\end{adjustwidth}\endMakeFramed%
        }

% 外源代码插入设置
    % matlab 代码插入设置
    %\usepackage{matlab-prettifier}
    %    \lstset{
    %        style=Matlab-editor,  % 继承matlab代码颜色等
    %    }
    %\usepackage[most]{tcolorbox} % 引入tcolorbox包 
    %\usepackage{listings} % 引入listings包
    %    \tcbuselibrary{listings, skins, breakable}
    %    \newfontfamily\codefont{Consolas} % 定义需要的 codefont 字体
    %    \lstdefinestyle{matlabstyle}{
    %        language=Matlab,
    %        basicstyle=\small\ttfamily\codefont,    % ttfamily 确保等宽 
    %        breakatwhitespace=false,
    %        breaklines=true,
    %        captionpos=b,
    %        keepspaces=true,
    %        numbers=left,
    %        numbersep=15pt,
    %        showspaces=false,
    %        showstringspaces=false,
    %        showtabs=false,
    %        tabsize=2
    %    }
    %    \newtcblisting{matlablisting}{
    %        arc=2pt,        % 圆角半径
    %        top=-5pt,
    %        bottom=-5pt,
    %        left=1mm,
    %        listing only,
    %        listing style=matlabstyle,
    %        breakable,
    %        colback=white   % 选一个合适的颜色
    %    }
% table 支持
    \usepackage{booktabs}   % 宏包：三线表
    \usepackage{tabularray} % 宏包：表格排版
    \usepackage{longtable}  % 宏包：长表格


%figure 设置
%    \usepackage{graphicx}  % 支持 jpg, png, eps, pdf 图片 
%    \usepackage{svg}       % 支持 svg 图片
%        \svgsetup{
%             指向 inkscape.exe 的路径
%            inkscapeexe = C:/aa_MySame/inkscape/bin/inkscape.exe, 
%            inkscapeexe = C:/aa_MySame/inkscape/bin/inkscape.exe, 
%             一定程度上修复导入后图片文字溢出几何图形的问题
%            inkscapelatex = false                 
%        }
%    \usepackage{subcaption} % subfigure 子图支持

%图表进阶设置
%    \usepackage{caption}    % 图注、表注
%        \captionsetup[figure]{name=图}  
%        \captionsetup[table]{name=表}
%        \captionsetup{labelfont=bf, font=small}
%    \usepackage{float}     % 图表位置浮动设置 

% 圆圈序号自定义
    \newcommand*\circled[1]{\tikz[baseline=(char.base)]{\node[shape=circle,draw,inner sep=0.8pt, line width = 0.03em] (char) {\small \bfseries #1};}}   % TikZ solution

% 列表设置
%    \usepackage{enumitem}   % 宏包：列表环境设置
%        \setlist[enumerate]{itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt, leftmargin=3.5em} 
%        \setlist[itemize]{itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt, leftmargin=3.5em}
%        \newlist{circledenum}{enumerate}{1} % 创建一个新的枚举环境  
%        \setlist[circledenum,1]{  
%            label=\protect\circled{\arabic*}, % 使用 \arabic* 来获取当前枚举计数器的值，并用 \circled 包装它  
%            ref=\arabic*, % 如果需要引用列表项，这将决定引用格式（这里仍然使用数字）
%            itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt, leftmargin=3.5em
%        }  

% 其它设置
    % 脚注设置
        \renewcommand\thefootnote{\ding{\numexpr171+\value{footnote}}}
    % 参考文献引用设置
        \bibliographystyle{unsrt}   % 设置参考文献引用格式为unsrt
        \newcommand{\upcite}[1]{\textsuperscript{\cite{#1}}}     % 自定义上角标式引用
    % 文章序言设置
        \newcommand{\cnabstractname}{序言}
        \newenvironment{cnabstract}{%
            \par\Large
            \noindent\mbox{}\hfill{\bfseries \cnabstractname}\hfill\mbox{}\par
            \vskip 2.5ex
            }{\par\vskip 2.5ex}

% 文章默认字体设置
    \usepackage{fontspec}   % 宏包：字体设置
        \setmainfont{SimSun}    % 设置中文字体为宋体字体
        \setCJKmainfont[AutoFakeBold=3]{SimSun} % 设置加粗字体为 SimSun 族，AutoFakeBold 可以调整字体粗细
        \setmainfont{Times New Roman} % 设置英文字体为Times New Roman

% 各级标题自定义设置
    \usepackage{titlesec}   
        \titleformat{\chapter}[hang]{\normalfont\huge\bfseries\centering}{第\,\thechapter\,章}{20pt}{}
        \titlespacing*{\chapter}{0pt}{-20pt}{20pt} % 控制上方空白的大小
        % section标题自定义设置 
        \titleformat{\section}[hang]{\normalfont\Large\bfseries}{§\,\thesection\,}{8pt}{}
        % subsubsection标题自定义设置
        %\titleformat{\subsubsection}[hang]{\normalfont\bfseries}{}{8pt}{}

% >> ------------------ 文章宏包及相关设置 ------------------ << %
% ------------------------------------------------------------- %

% ----------------------------------------------------------- %
% >> --------------------- 文章信息区 --------------------- << %
% 页眉页脚设置
    \usepackage{fancyhdr}   %宏包：页眉页脚设置
        \pagestyle{fancy}
        \fancyhf{}
        \cfoot{\thepage}
        \renewcommand\headrulewidth{1pt}
        \renewcommand\footrulewidth{0pt}
        \lhead{2024.8 -- 2025.1} 
        \chead{yinchao050313@gmail.com}    
        \rhead{yinchao23@mails.ucas.ac.cn}
%文档信息设置
    \title{离散数学\\Discrete Mathematics}
    \author{尹超\\ \footnotesize 中国科学院大学，北京 100049\\ Carter Yin \\ \footnotesize University of Chinese Academy of Sciences, Beijing 100049, China}
    \date{\footnotesize 2024.8 -- 2025.1}
% >> --------------------- 文章信息区 --------------------- << %
% ----------------------------------------------------------- %

% 开始编辑文章

\begin{document} 
\zihao{5}             % 设置全文字号大小, -4 为小四, 5 为五号

% --------------------------------------------------------------- %
% >> --------------------- 封面序言与目录 --------------------- << %
% 封面
    \maketitle\newpage  
    \pagenumbering{Roman} % 页码为大写罗马数字
    \thispagestyle{fancy}   % 显示页码、页眉等

% 序言
    \begin{cnabstract}\normalsize 
        本笔记为离散数学的笔记整理\par
        讲课教师:\par
        • 吴凌云，国科大教授，中国科学院数学与系统科学研究院\par
        • email: lywu@amss.ac.cn\par
        助教：\par
        • 田晓云（xiaoyuntian@amss.ac.cn）\par
        • 徐雪晴（xuxueqing@amss.ac.cn）\par
        • 张瑞扬（zhangruiyang@amss.ac.cn）
\end{cnabstract}    
\addcontentsline{toc}{chapter}{序言} % 手动添加为目录

% 目录
    \setcounter{tocdepth}{4}                % 目录深度（为1时显示到section）
    \tableofcontents                        % 目录页
    \addcontentsline{toc}{chapter}{目录}    % 手动添加此页为目录
    \thispagestyle{fancy}                   % 显示页码、页眉等 

% 收尾工作
    \newpage    
    \pagenumbering{arabic} 


% >> --------------------- 封面序言与目录 --------------------- << %
% --------------------------------------------------------------- %


\chapter{基础：逻辑和证明}\thispagestyle{fancy} 

\section{逻辑}

\section{命题}

\begin{definition}
\subsection{命题}
• 原子命题（atomic proposition）\par
– 不能用更简单的命题来表示的命题，称为原子命题\par
• 复合命题（compound proposition）\par
– 由已知命题用逻辑运算符组合而来的新命题，称为复合命题\par
\end{definition}

\subsection{真值表}
\begin{definition}
下面是一个包含所有真值运算的真值表（包括异或运算）
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
$p$ & $q$ & $\neg p$ & $p \land q$ & $p \lor q$ & $p \rightarrow q$ & $p \leftrightarrow q$ & $p \oplus q$  \\
\hline
T & T & F & T & T & T & T & F  \\
T & F & F & F & T & F & F & T  \\
F & T & T & F & T & T & F & T  \\
F & F & T & F & F & T & T & F  \\
\hline
\end{tabular}
\end{table}
\end{definition}

\subsection{比特运算真值表}
\begin{definition}
下面是一个和上面的表对应的比特运算真值表
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
$p$ & $q$ & $\neg p$ & $p \land q$ & $p \lor q$ & $p \rightarrow q$ & $p \leftrightarrow q$ & $p \oplus q$  \\
\hline
1 & 1 & 0 & 1 & 1 & 1 & 1 & 0  \\
1 & 0 & 0 & 0 & 1 & 0 & 0 & 1  \\
0 & 1 & 1 & 0 & 1 & 1 & 0 & 1  \\
0 & 0 & 1 & 0 & 0 & 1 & 1 & 0  \\
\hline
\end{tabular}
\end{table}
\end{definition}

\cleardoublepage

\subsection{逻辑电路}
\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{C:/Users/78003/Desktop/lisan/1.2.4.png}
\caption{逻辑电路}
\end{figure}

\section{范式}
\subsection{析取范式}
\begin{definition}
    一个析取范式的例子\par
    \begin{equation}
        (p \land q) \lor (\neg p \land r) \lor (q \land r)
    \end{equation}
\end{definition}

\subsection{合取范式}
\begin{definition}
    一个合取范式的例子\par
    \begin{equation}
        (p \lor q) \land (\neg p \lor r) \land (q \lor r)
    \end{equation}
\end{definition}


\section{谓词和量词}

\subsection{谓词逻辑的例子}

\begin{definition}
    谓词逻辑的例子\par
    \begin{equation}
        \forall x \in \R, \exists y \in \R, y > x
    \end{equation}
\end{definition}

\subsection{n元谓词}

\begin{definition}
    n元谓词的例子\par
    \begin{equation}
        \forall x_1, x_2, \cdots, x_n \in \R, \exists y \in \R, y > x_1 + x_2 + \cdots + x_n
    \end{equation}
\end{definition}

\subsection{量词}

\subsubsection{量词}

\begin{definition}
    \textbf{量化（quantification）}\par
    当命题函数中的变量均被赋值时，就得到一个具有真值的命题\par
    量化是另一种从命题函数生成一个命题的重要方式\par
    量化表示在何种程度上谓词对于一定范围的对象成立\par
    自然语言中用于量化的词包括：所有、某些、许多、没有、少量、大多数等\par

    \textbf{论域（domain of discourse）}\par
    也称为全体域（universe of discourse），简称为域（domain）\par
    命题函数中变量的取值范围\par
\end{definition}

\subsubsection{全称量化}

\begin{definition}
    \textbf{全称量化（universal quantification）}\par
    $P(x)$ 的全称量化是命题“$P(x)$ 对 $x$ 在其论域的所有值为真”\par
    $P(x)$ 的全称量化表示为 $\forall x P(x)$ ，读作“对所有 $x,P(x)$ ”\par
    $\forall$ 称为全称量词（universal quantifier）\par
    一个使 $P(x)$ 为假的域中元素 $x$ 称为 $\forall x P(x)$ 的反例（counterexample）\par

    \textbf{全称量化为假}\par
    一个全称量化 $\forall x P(x)$ 为假当且仅当“有一个 $x$ 使得 $P(x)$ 为假”\par
    寻找一个 $\forall x P(x)$ 的反例\par
    只需要一个反例就可以确定 $\forall x P(x)$ 为假\par

    \textbf{论域}\par
    使用量词时，必须指定论域，量化命题的真值通常取决于论域\par
    通常一个隐含的假设是，量词的论域均为非空的\par
    如果论域为空，“有一个 $x，P(x)$ 为假”不成立，所以对任意命题函数 $P(x)$ ，都有 $\forall x P(x)$ 为真\par
\end{definition}

\subsubsection{存在量化}

\begin{definition}
    \textbf{存在量化（existential quantification）}\par
    $P(x)$ 的存在量化是命题“论域中存在一个 $x$ 使得 $P(x)$ 为真”\par
    $P(x)$ 的存在量化表示为 $\exists x P(x)$ ，读作“存在 $x,P(x)$ ”\par
    $\exists$ 称为存在量词（existential quantifier）\par

    \textbf{存在量化为假}\par
    一个存在量化 $\exists x P(x)$ 为假当且仅当“论域中没有 $x$ 使得 $P(x)$ 为真”\par
    对论域中每一个元素 $x$，$P(x)$ 都为假\par

    \textbf{论域}\par
    使用量词时，必须指定论域，量化命题的真值通常取决于论域\par
    通常一个隐含的假设是，量词的论域均为非空的\par
    如果论域为空，“有一个 $x,P(x)$ 为真”不成立，所以对任意命题函数 $P(x)$ ，都有 $\exists x P(x)$ 为假\par
\end{definition}

\subsubsection{唯一性量词}

\begin{definition}
    \textbf{唯一性量词（uniqueness quantifier）}\par
    用符号 $\exists !$ 或 $\exists 1$ 表示\par
    $\exists ! x P(x)$ 表示“存在一个唯一的 $x$ 使得 $P(x)$ 为真”\par
    唯一性量词可以避免使用：用全称量化、存在量化和逻辑运算符来表示\par
    通常只使用全称量词和存在量词，这样可以使用这些量词的推理规则\par
\end{definition}

\subsection{有限域上的量词}

\begin{definition}
    \textbf{有限域上的量词}\par
    当一个量词的域是有限的，即所有元素可以一一列出时，量化语句可以用命题逻辑来表达\par
    当论域中的元素为 $x_1, x_2, \cdots , x_n$，其中 $n$ 是一个正整数，则\par
    全称量化 $\forall x P(x) \equiv P(x_1) \land P(x_2) \land \cdots \land P(x_n)$\par
    存在量化 $\exists x P(x) \equiv P(x_1) \lor P(x_2) \lor \cdots \lor P(x_n)$\par

    \textbf{量化和循环}\par
    确定量化命题的真值时，可以借助循环和搜索来进行思考\par
    对有限域中的所有元素进行循环遍历，检查量化命题是否为真\par
\end{definition}

\subsection{受限域的量词}

\begin{definition}
    \textbf{受限域的量词}\par
    有时候我们需要限定一个量词的论域\par
    一个简单的表示法：把变量必须满足的条件放在量词后面\par
    示例1：\par
    $\forall x < 0 \, (x^2 > 0)$\par
    $\forall y \neq 0 \, (y^3 \neq 0)$\par
    $\exists z > 0 \, (z^2 = 2)$\par

    受限的全称量化和一个条件语句的全称量化等价\par
    $\forall P(x) Q(x) \equiv \forall x (P(x) \rightarrow Q(x))$\par
    受限的存在量化和一个合取式的存在量化等价\par
    $\exists P(x) Q(x) \equiv \exists x (P(x) \land Q(x))$\par
    示例2：\par
    $\forall x < 0 \, (x^2 > 0)$ 等价于 $\forall x (x < 0 \rightarrow x^2 > 0)$\par
    $\exists z > 0 \, (z^2 = 2)$ 等价于 $\exists z (z > 0 \land z^2 = 2)$\par
\end{definition}

\subsection{量词的优先级}

\begin{definition}
    \textbf{量词比命题逻辑中的所有逻辑运算符都具有更高的优先级}\par
    示例：\par
    $\forall x P(x) \lor Q(x)$ 表示 $(\forall x P(x)) \lor Q(x)$\par
    $\exists x P(x) \rightarrow Q(x)$ 表示 $(\exists x P(x)) \rightarrow Q(x)$\par
    要表示 $P(x) \lor Q(x)$ 的全称量化，必须写为 $\forall x (P(x) \lor Q(x))$\par
    要表示 $P(x) \rightarrow Q(x)$ 的存在量化，必须写为 $\exists x (P(x) \rightarrow Q(x))$\par
\end{definition}

\subsection{量化表达式的否定}

\begin{definition}
    \textbf{量词的德·摩根律}\par
    $\neg \forall x P(x) \equiv \exists x \neg P(x)$\par
    $\neg \exists x P(x) \equiv \forall x \neg P(x)$\par
    当一个量词的域是有限的时候，全称量化等价于一个合取式，存在量化等价于一个析取式，此时量化命题的否定和德·摩根律完全相同，所以把量化表达式的否定规则称为量词的德·摩根律\par

    \textbf{示例：}\par
    $\forall x \, (x^2 > x)$ 的否定是 $\neg \forall x \, (x^2 > x) \equiv \exists x \neg (x^2 > x) \equiv \exists x \, (x^2 \leq x)$\par
    $\exists x \, (x^2 = 2)$ 的否定是 $\neg \exists x \,(x^2 = 2) \equiv \forall x \neg (x^2 = 2) \equiv \forall x \, (x^2 \neq 2)$\par
    $\neg \forall x (P(x) \rightarrow Q(x)) \equiv \exists x \neg (P(x) \rightarrow Q(x))$ 量词的德·摩根律\par
    $\equiv \exists x \neg (\neg P(x) \lor Q(x))$ 条件−析取等价式\par
    $\equiv \exists x (P(x) \land \neg Q(x))$ 德·摩根律\par
\end{definition}

\subsection{空量化}

\begin{definition}
    \textbf{空量化（null quantification）规则}\par
    \textcolor{red}{前提：论域非空}

    ① $\forall x P(x) \lor A \equiv \forall x (P(x) \lor A)$\par
    ② $\exists x P(x) \lor A \equiv \exists x (P(x) \lor A)$\par
    ③ $\forall x P(x) \land A \equiv \forall x (P(x) \land A)$\par
    ④ $\exists x P(x) \land A \equiv \exists x (P(x) \land A)$\par
    ⑤ $A \rightarrow \forall x P(x) \equiv \forall x (A \rightarrow P(x))$\par
    ⑥ $A \rightarrow \exists x P(x) \equiv \exists x (A \rightarrow P(x))$\par
    ⑦ $\forall x P(x) \rightarrow A \equiv \exists x (P(x) \rightarrow A)$\par
    $\forall x (A \rightarrow P(x)) \equiv \forall x (\neg A \lor P(x)) \equiv \neg A \lor \forall x P(x) \equiv A \rightarrow \forall x P(x)$\par
    ⑧ $\exists x P(x) \rightarrow A \equiv \forall x (P(x) \rightarrow A)$\par
    $\exists x (P(x) \rightarrow A) \equiv \exists x (\neg P(x) \lor A) \equiv \neg \forall x P(x) \lor A \equiv \forall x P(x) \rightarrow A$\par
\end{definition}

\subsection{嵌套量词}

\begin{definition}
    \textbf{嵌套量词（nested quantifier）}\par
    一个量词出现在另一个量词的作用域内\par
    嵌套量词经常出现在数学和计算机科学中\par
    \vspace{1em} % 添加一个空行
    \textbf{示例：}\par
    假定变量 $x$ 和 $y$ 的论域是所有实数\par
    命题 $\forall x \forall y (x + y = y + x)$ 表示加法的交换律\par
    命题 $\forall x \exists y (x + y = 0)$ 表示每一个实数都存在一个加法的逆\par
    命题 $\forall x \forall y \forall z (x + y + z = x + y + z)$ 表示加法的结合律\par
    \vspace{1em} % 添加一个空行
    在处理多个变量的嵌套量化式时，可以借助嵌套循环进行思考\par
    同类型的量词嵌套，比较容易理解\par
    要判定 $\forall x \exists y P(x, y)$ 的真值，先对 $x$ 的所有可能取值进行循环，对每个固定的 $x$，再对 $y$ 的所有可能取值进行循环，搜索是否存在一个特定的 $y$ 使得 $P(x, y)$ 为真，如果对每个 $x$ 都存在一个这样的 $y$，那么这个量化命题为真，如果有一个 $x$ 找不到这样的 $y$，那么量化命题为假\par
    要判定 $\exists x \forall y P(x, y)$ 的真值，先对 $x$ 的所有可能取值进行循环，对每个固定的 $x$，再对 $y$ 的所有可能取值进行循环，判断是否 $y$ 的所有可能取值都使得 $P(x, y)$ 为真，如果对某个 $x$ 成立，那么这个量化命题为真，如果对所有的 $x$ 都不成立，那么量化命题为假\par
    \vspace{1em} % 添加一个空行
    嵌套量词的顺序是很重要的，除非所有量词都是同一类型的\par
    $\forall x \forall y P(x, y) \equiv \forall y \forall x P(x, y)$\par
    $\exists x \exists y P(x, y) \equiv \exists y \exists x P(x, y)$\par
    $\exists y \forall x P(x, y) \rightarrow \forall x \exists y P(x, y) \equiv T$\par
    \vspace{1em} % 添加一个空行
    \textbf{示例1：}\par
    令 $P(x, y)$ 表示“$x + y = 0$”，论域为所有实数\par
    $\forall x \exists y P(x, y)$ 表示“对每个实数 $x$ 都存在一个加法的逆”，该命题为真\par
    $\exists y \forall x P(x, y)$ 表示“存在一个实数 $y$ 和任意实数的和为 0”，该命题为假\par
    \vspace{1em} % 添加一个空行
    \textbf{示例2：}\par
    论域为实数，$P(x, y)$ 表示 $xy = 0$\par
    $\forall x \forall y P(x, y) = ?$\par
    $\exists x \exists y P(x, y) = ?$\par
    $\forall x \exists y P(x, y) = ?$\par
    $\exists x \forall y P(x, y) = ?$\par
\end{definition}

\subsection{嵌套量词的否定}

\begin{definition}
    • 嵌套量词语句的否定可以通过连续应用单个量词的否定规则得到\par
    • $\neg \forall x \forall y P(x, y) \equiv \exists x \neg \forall y P(x, y) \equiv \exists x \exists y \neg P(x, y)$\par
    • $\neg \forall x \exists y P(x, y) \equiv \exists x \neg \exists y P(x, y) \equiv \exists x \forall y \neg P(x, y)$\par
    • $\neg \exists x \forall y P(x, y) \equiv \forall x \neg \forall y P(x, y) \equiv \forall x \exists y \neg P(x, y)$\par
    • $\neg \exists x \exists y P(x, y) \equiv \forall x \neg \exists y P(x, y) \equiv \forall x \forall y \neg P(x, y)$\par
\end{definition}


\section{前束范式}

\begin{definition}
    \textbf{前束范式（prenex normal form，PNF）}\par
    形式为 $Q_1 x_1 Q_2 x_2 \cdots Q_k x_k P(x_1, x_2, \cdots, x_k)$ 的逻辑表达式，其中 $Q_i$ 为全称量词或存在量词，且 $P(x_1, x_2, \cdots, x_k)$ 是不含量词的谓词\par
    每个由命题变量、谓词、T 和 F、逻辑联结词、量词构成的语句都等价于一个前束范式\par
    一个前束范式可以通过一系列等价变换得到\par

    \textbf{示例：}\par
    $\forall x \exists y (P(x, y) \land Q(y))$ 是前束范式\par
    $\exists x P(x) \lor \forall x Q(x)$ 不是前束范式，等价于 $\exists x \forall y (P(x) \lor Q(y))$\par
\end{definition}

\section{推理规则}

\subsection{推理规则}

\begin{definition}
    \textbf{数学中的证明（proof）是建立数学命题真实性的有效论证}\par
    论证（argument）是指一连串的命题并以结论为最后命题\par
    有效（valid）是指结论或论证的最后一个命题必须根据论证前面的命题或前提的真实性推出\par
    一个论证是有效的当且仅当不可能出现所有前提为真而结论为假的情况\par

    \textbf{推理规则（rules of inference）}\par
    从已知命题中推出新的命题\par
    是构造有效论证的模板，是建立命题真实性的基本工具\par
\end{definition}

\subsection{命题逻辑中的有效论证}

\begin{definition}
    \textbf{命题逻辑中的有效论证}\par
    \vspace{1em} % 添加一个空行
    \textbf{示例：}\par
    考虑如下论证：\par
    “如果你有一个WiFi密码，那么你可以登录到网络”\par
    “你有一个WiFi密码”\par
    所以，“你可以登录到网络”\par
    \vspace{1em} % 添加一个空行
    令 $p$ 表示“你有一个WiFi密码”，$q$ 表示“你可以登录到网络”\par
    那么这个论证形式化表示如下：\par
    $p \rightarrow q$\par
    $p$\par
    $\therefore q$\par
    \vspace{1em} % 添加一个空行
    对于命题变量 $p$ 和 $q$，因为 $p \rightarrow q \land p \rightarrow q$ 是一个永真式\par
    所以当 $p \rightarrow q$ 和 $p$ 都为真时，$q$ 肯定为真\par
    我们说这种论证形式是有效的\par
    无论用什么命题替换 $p$ 和 $q$，只要 $p \rightarrow q$ 和 $p$ 都为真，那么 $q$ 肯定为真\par
\vspace{1em} % 添加一个空行
    考虑如下论证：\par
    “如果你有一个WiFi密码，那么你可以修改你的成绩”\par
    “你有一个WiFi密码”\par
    所以，“你可以修改你的成绩”\par
    该论证也是有效论证，但是其中第一个前提为假，所以不能得出结论为真\par
\end{definition}

\subsection{命题逻辑的推理规则}

\begin{definition}
    \textbf{命题逻辑的推理规则}\par
    \vspace{1em} % 添加一个空行
    \textbf{论证（argument）}\par
    命题逻辑中的一个论证是一连串的命题\par
    除了论证中的最后一个命题外，其他命题都叫做前提（premise），最后一个命题叫作结论（conclusion）\par
    一个论证是有效的，如果它的所有前提为真蕴含着结论为真\par
    \vspace{1em} % 添加一个空行
    \textbf{论证形式（argument form）}\par
    命题逻辑中的论证形式是一连串涉及命题变量的复合命题\par
    无论用什么特定命题替换其中的命题变量，如果所有前提为真时结论为真，称该论证形式是有效的\par
    \vspace{1em} % 添加一个空行
    一个论证的有效性来自于论证形式的有效性\par
    根据论证形式有效性的定义\par
    当 $p_1 \land p_2 \land \cdots \land p_n \rightarrow q$ 是永真式时\par
    带有前提 $p_1, p_2, \cdots, p_n$ 和结论 $q$ 的论证形式是有效的\par
    \vspace{1em} % 添加一个空行
    我们总是可以用真值表来证明一个论证形式是有效的\par
    前提为真（不是命题变量为真）则结论肯定为真\par
    真值表规模 $2^m$ （$m$ 为命题变量的数量）\par
    \vspace{1em} % 添加一个空行
    一些相对简单的论证形式可以作为基本构件来构造更复杂的有效论证形式\par
\end{definition}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{C:/Users/78003/Desktop/lisan/1.5.3.png}
\caption{命题逻辑的推理规则}
\end{figure}

\subsection{消解规则}

\begin{definition}
    \textbf{消解式（resolvent）}\par
    消解规则基于永真式 $((p \lor q) \land (\neg p \lor r)) \rightarrow (q \lor r)$\par
    消解规则最后的结论 $q \lor r$ 称为消解式\par

    \textbf{消解规则}\par
    消解规则在逻辑规则编程语言中扮演着重要角色\par
    消解规则可以用来构建自动定理证明系统\par
    将前提和结论都表示为合取范式，即由子句（每个子句为命题变量或其否定的一个析取式）构成\par

    \textbf{示例1：}\par
    用消解规则证明假言推理\par
    假言推理的前提为 $p \rightarrow q$ 和 $p$，结论为 $q$\par
    将前提分别改写为子句 $\neg p \lor q$ 和 $p \lor F$，消解可得到 $q \lor F$，即 $q$\par

    \textbf{示例2：}\par
    用消解规则证明拒取式\par
    拒取式的前提为 $p \rightarrow q$ 和 $\neg q$，结论为 $\neg p$\par
    将前提分别改写为子句 $q \lor \neg p$ 和 $\neg q \lor F$，消解可得到 $\neg p \lor F$，即 $\neg p$\par

    \textbf{示例3：}\par
    用消解规则证明析取三段论\par
    析取三段论的前提为 $p \lor q$ 和 $\neg p$，结论为 $q$\par
    将前提分别改写为子句 $p \lor q$ 和 $\neg p \lor F$，消解可得到 $q \lor F$，即 $q$\par

    \textbf{示例4：}\par
    用消解规则证明假言三段论\par
    假言三段论的前提为 $p \rightarrow q$ 和 $q \rightarrow r$，结论为 $p \rightarrow r$\par
    将前提分别改写为子句 $q \lor \neg p$ 和 $\neg q \lor r$，消解可得到 $\neg p \lor r$，即 $p \rightarrow r$\par

    \textbf{示例5：}\par
    用消解规则证明 $p \land q \lor r$ 和 $r \rightarrow s$ 蕴含结论 $p \lor s$\par
    将第一个前提改写为两个子句 $p \lor r$ 和 $q \lor r$\par
    将第二个前提改写为子句 $\neg r \lor s$\par
    使用子句 $p \lor r$ 和 $\neg r \lor s$ 进行消解可得到 $p \lor s$\par
\end{definition}

\subsection{谬误}

\begin{definition}
    \textbf{谬误（fallacy）}\par
    谬误是一些常见的错误推理，直接导致无效论证\par
    谬误基于可满足式而不是永真式\par
    
    \textbf{肯定结论的谬误（fallacy of affirming the conclusion）}\par
    基于可满足式 $((p \rightarrow q) \land q) \rightarrow p$ 把逆命题当成等价命题\par
    
    \textbf{否定假设的谬误（fallacy of denying the hypothesis）}\par
    基于可满足式 $((p \rightarrow q )\land \neg p) \rightarrow \neg q$ 把反命题当成等价命题\par
\end{definition}

\subsection{量化命题的推理规则}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{C:/Users/78003/Desktop/lisan/1.5.6.png}
\caption{量化命题的推理规则}
\end{figure}

\subsection{命题和量化命题推理规则的组合使用}

\begin{definition}
    \textbf{某些量化命题推理规则和命题推理规则经常一起使用}\par

    \textbf{全称假言推理（universal modus ponens）}\par
    $\forall x (P(x) \rightarrow Q(x))$\par
    $P(a)$\par
    $ \therefore Q(a)$\par

    \textbf{全称拒取式（universal modus tollens）}\par
    $\forall x (P(x) \rightarrow Q(x))$\par
    $\neg Q(a)$\par
    $ \therefore \neg P(a)$\par
\end{definition}


\section{证明}

\subsection{证明导论}

\begin{definition}
    \textbf{证明（Proof）}\par
    证明是建立（数学）语句真实性的有效论证\par

    \textbf{证明可以使用}\par
    \begin{itemize}
        \item 定理的假设、定义
        \item 假定为真的公理（axiom）
        \item 之前已经被证明的定理
        \item 推理规则
    \end{itemize}

    \textbf{形式化证明（formal proof）}\par
    \begin{itemize}
        \item 提供论证的详细步骤，以及论证中每一步用到的规则
        \item 非常冗长，而且难以理解
    \end{itemize}

    \textbf{非形式化证明（informal proof）}\par
    \begin{itemize}
        \item 每个步骤会用到多于一条的推理规则，有些步骤被省略
        \item 不会显式地列出所用的假设公理和推理规则
        \item 简洁，容易理解和解释
        \item 容易引入错误
    \end{itemize}
\end{definition}

\subsection{术语}

\begin{definition}
    \textbf{定理（theorem）}\par
    一个能够被证明是真的语句\par
    不太重要的定理有时称为命题\par
\vspace{1em} % 添加一个空行
    \textbf{引理（lemma）}\par
    重要性略低但有助于证明其他结论的定理\par
\vspace{1em} % 添加一个空行
    \textbf{推论（corollary）}\par
    从一个已经被证明的定理可以直接建立起来的定理\par
\vspace{1em} % 添加一个空行
    \textbf{猜想（conjecture）}\par
    被提出认为是真的命题，通常基于部分证据、启发式论证、专家直觉\par
\end{definition}


\subsection{定理的证明}

\begin{definition}
    \textbf{很多定理都具有如下的形式 $\forall x (P(x) \rightarrow Q(x))$}\par
    证明这种类型定理的过程通常包括：\par
    \begin{itemize}
        \item 选择论域中的一个一般性元素 $c$
        \item 证明这个元素具有所考虑的性质，即 $P(c) \rightarrow Q(c)$
        \item 全称引入，证明定理对论域中所有元素都成立\par
    \end{itemize}
    所以我们经常需要证明条件语句 $p \rightarrow q$ 为真\par
    条件语句 $p \rightarrow q$ 为真，除非出现了 $p$ 为真且 $q$ 为假的情形\par
    因此我们只需要证明，如果 $p$ 为真则 $q$ 一定为真\par
\vspace{1em} % 添加一个空行
    \textbf{平凡证明（trivial proof）}\par
    如果 $q$ 为真，则 $p \rightarrow q$ 也一定为真\par
    常用于证明定理的一些特例、数学归纳法\par
\vspace{1em} % 添加一个空行
    \textbf{示例：}\par
    设 $P(n)$ 表示“如果 $a$ 和 $b$ 是满足 $a \geq b$ 的正整数，则 $a^n \geq b^n$”，论域为所有非负整数\par
    考虑 $n = 0$ 的情形，实际上 $a^0 \geq b^0$ 对于所有正整数 $a$ 和 $b$ 成立\par
    所以命题 $P(0)$ 为真（前提 $a \geq b$ 没有使用）\par
\vspace{1em}
    \textbf{空证明（vacuous proof）}\par
    当 $p$ 为假时，$p \rightarrow q$ 一定为真\par
    常用于证明定理的一些特例\par
\vspace{1em}
    \textbf{示例：}\par
    设 $P(n)$ 表示“如果 $n > 1$，则 $n^2 > n$”，论域为所有整数\par
    考虑 $n = 0$ 的情形，此时 $n > 1$ 为假\par
    所以命题 $P(0)$ 为真（虽然 $0^2 > 0$ 为假）\par
\end{definition}


\subsection{直接证明法}

\begin{definition}
    \textbf{直接证明法（direct proof）}\par
    假设 $p$ 为真，然后利用推理规则、逻辑等价式、公理等构造新的命题，直至证明 $q$ 也为真\par
    需要特殊的洞察力\par

    \textbf{示例1：}\par
    证明“如果 $n$ 是奇数，则 $n^2$ 是奇数”\par
    假设 $n$ 是奇数，则由奇数定义，$n = 2k + 1$，其中 $k$ 是某个整数\par
    $n^2 = (2k + 1)^2 = 4k^2 + 4k + 1 = 2(2k^2 + 2k) + 1$\par
    由奇数定义，$n^2$ 是奇数\par

    \textbf{示例2：}\par
    证明“两个有理数的和是有理数”\par
    假设 $r$ 和 $s$ 是有理数，则由有理数定义，$r = \frac{p}{q}$，$s = \frac{u}{v}$，其中 $p, q, u, v$ 是整数且 $q \neq 0$，$v \neq 0$\par
    $r + s = \frac{p}{q} + \frac{u}{v} = \frac{pv + qu}{qv} = \frac{t}{w}$，其中 $t = pv + qu$，$w = qv \neq 0$ 为整数\par
    由有理数定义，$r + s$ 为有理数\par
\end{definition}

\subsection{反证法}

\begin{definition}
    \textbf{间接证明法（indirect proof）}\par
    直接证明法有的时候比较困难\par
    不从前提开始、以结论结束的证明方法叫间接证明法\par
    \vspace{1em} % 添加一个空行 
    反证法（proof by contraposition）\par
    归谬证明法（proof by contradiction）\par
\vspace{1em} % 添加一个空行
    \textbf{反证法（proof by contraposition）}\par
    条件语句 $p \rightarrow q$ 等价于它的逆否命题 $\neg q \rightarrow \neg p$\par
    证明当 $\neg q$ 为真时，$\neg p$ 一定为真\par
\vspace{1em} % 添加一个空行
    \textbf{示例1：}\par
    证明“如果 $n$ 是一个整数且 $3n + 2$ 是奇数，则 $n$ 是奇数”\par
    直接证明比较困难\par
    假设 $n$ 不是奇数，即 $n$ 为偶数，则 $n = 2k$，$k$ 为某个整数\par
    $3n + 2 = 3(2k) + 2 = 6k + 2 = 2(3k + 1)$，即 $3n + 2$ 为偶数，逆否命题为真，所以原命题也为真\par
\vspace{1em} % 添加一个空行
    \textbf{示例2：}\par
    证明“如果 $n$ 是一个整数且 $n^2$ 是奇数，则 $n$ 是奇数”\par
    直接证明比较困难：假设 $n^2$ 是奇数，很难推导下去\par
    假设 $n$ 不是奇数，即 $n$ 为偶数，则 $n = 2k$，$k$ 为某个整数\par
    $n^2 = (2k)^2 = 4k^2 = 2(2k^2)$，即 $n^2$ 为偶数\par
    即我们证明了逆否命题“如果 $n$ 是一个偶数，则 $n^2$ 是偶数”\par
    由反证法，“如果 $n$ 是一个整数且 $n^2$ 是奇数，则 $n$ 是奇数”\par
\end{definition}

\subsection{归谬证明法}

\begin{definition}
    \textbf{归谬证明法（proof by contradiction）}\par
    假设我们需要证明命题 $s$ （不一定是条件语句）\par
    如果能够证明条件语句 $\neg s \rightarrow r$ 为真，而且 $r$ 为矛盾式，那么 $s$ 为真\par
    因为 $r$ 为矛盾式，所以条件语句 $\neg s \rightarrow r$ 等价于 $\neg s \rightarrow F$，而 $\neg s \rightarrow F$ 的逆否命题为 $T \rightarrow s$\par
\vspace{1em}
    \textbf{示例1：}\par
    证明“任意22天中至少有4天属于每星期的同一天”\par
    假设命题为假，即“任意22天中至多有3天属于每星期的同一天”，而一个星期有7天，这蕴含着至多可以选出21天，与命题的前提“22天”矛盾\par
\vspace{1em}
    \textbf{示例2：}\par
    证明“$\sqrt{2}$ 是无理数”\par
    假设命题为假，即“$\sqrt{2}$ 不是无理数”，则“$\sqrt{2}$ 是有理数”\par
    那么存在整数 $p$ 和 $q$ 使得 $\sqrt{2} = \frac{p}{q}$，其中 $q \neq 0$ 且 $p$ 和 $q$ 没有公约数\par
    两端取平方，可得 $2 = \frac{p^2}{q^2}$，即 $2q^2 = p^2$\par
    所以 $p^2$ 为偶数，那么 $p$ 也是偶数，存在整数 $r$ 使得 $p = 2r$\par
    因此 $2q^2 = p^2 = (2r)^2 = 4r^2 = 2(2r^2)$，即 $q^2 = 2r^2$\par
    所以 $q^2$ 为偶数，那么 $q$ 也是偶数，$p$ 和 $q$ 有公约数 2，矛盾\par
\vspace{1em}
    \textbf{示例3：}\par
    证明“素数的个数是无限的”\par
    假设命题为假，即“素数的个数是有限的”\par
    设素数的个数为 $n$，从小到大排列为 $p_1 = 2, p_2 = 3, \cdots, p_n$\par
    考虑整数 $m = p_1 \times p_2 \times \cdots \times p_n + 1$\par
    因为 $p_1, p_2, \cdots, p_n$ 都不能整除 $m$，所以 $m$ 是一个素数\par
    这与“素数的个数为 $n$”矛盾\par
    所以“素数的个数是无限的”\par
\vspace{1em}
    归谬证明法可以用于条件语句\par
    条件语句 $p \rightarrow q$ 等价于 $\neg p \lor q$\par
    假设 $\neg (\neg p \lor q)$ 为真，即 $p \land \neg q$ 为真，推导出矛盾式，则原命题为真\par
\vspace{1em}
    归谬证明法和反证法\par
    条件语句的反证法证明可以改写为归谬证明\par
    反证法：假设 $\neg q$ 为真，推导出 $\neg p$ 为真\par
    归谬证明法：假设 $\neg q$ 和 $p$ 为真，推导出 $\neg p \land p$ 为真\par
\vspace{1em}
    归谬证明法和直接证明法\par
    条件语句 $p \rightarrow q$ 的直接证明可以改写为归谬证明\par
    直接证明：假设 $p$ 为真，推导出 $q$ 为真\par
    归谬证明法：假设 $p$ 和 $\neg q$ 为真，推导出 $q \land \neg q$ 为真\par
\end{definition}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{C:/Users/78003/Desktop/lisan/1.6.3.png}
\caption{证明方法}
\end{figure}

\textbf{在证明形如 $\forall x (P(x) \rightarrow Q(x))$ 的命题时}\par
首先可以评估直接证明法是否可行\par
通过展开前提，结合公理和可用的定理，利用推理规则进行推理\par
\vspace{1em}
尝试使用反证法\par
对于不容易从前提开始推理的，从结论的否定开始推理\par
\vspace{1em}
尝试使用归谬证明法\par
从前提和结论的否定同时开始推理\par
\vspace{1em}
尝试寻找反例\par
\vspace{1em}
\textbf{反例证明法（proof by counter examples）}\par
要证明形如 $\forall x P(x)$ 的语句为假，可以采用反例证明法\par
只要找到一个反例 $c$，使得 $P(c)$ 为假即可\par
\vspace{1em}
\textbf{示例：}\par
证明“每个正整数都是两个整数的平方和”为假\par
3 就是一个反例\par
不超过 3 的平方数只有 0 和 1\par
0 和 1 的任意两项之和都不等于 3\par
\vspace{1em}
有些定理是双条件语句，即定理形式表示为 $p \leftrightarrow q$\par
证明双条件语句，我们需要证明 $p \rightarrow q$ 和 $q \rightarrow p$ 都为真\par
\vspace{1em}
有些定理会阐述多个命题都是互相等价的，即 $\forall i \forall j (p_i \leftrightarrow p_j)$\par
证明这种命题可以直接证明 $\forall i \forall j (p_i \rightarrow p_j)$\par
\vspace{1em}
一种更有效的方式是利用等价式\par
$\forall i \forall j (p_i \leftrightarrow p_j) \equiv (p_1 \rightarrow p_2) \land (p_2 \rightarrow p_3) \land \cdots \land (p_n \rightarrow p_1)$\par
\vspace{1em}
\textbf{示例：}\par
证明下列三个关于整数 $n$ 的语句是等价的\par
$p_1$: $n$ 是偶数\par
$p_2$: $n^2$ 是偶数\par
$p_3$: $n - 1$ 是奇数\par

可以通过证明 $p_1 \rightarrow p_3$，$p_3 \rightarrow p_2$，$p_2 \rightarrow p_1$ 来证明三个语句是等价的\par
$p_1 \rightarrow p_3$ 可以用直接证明法\par
$p_3 \rightarrow p_2$ 也可以用直接证明法\par
$p_2 \rightarrow p_1$ 可以用反证法\par

\subsection{证明中的错误}

\begin{definition}
    \textbf{证明中的错误可能来自两个方面}\par
    \begin{itemize}
        \item 错误使用公理/定理/已知条件
        \item 错误的推理规则
    \end{itemize}

    \textbf{示例1：}\par
    命题：如果 $n^2$ 是正数，则 $n$ 是正数\par
    证明：假定 $n^2$ 是正数。因为命题“如果 $n$ 是正数，则 $n^2$ 是正数”为真，所以 $n$ 是正数。\par
    错误：从条件语句 $\forall n (P(n) \rightarrow Q(n))$ 和前提 $Q(n)$ 不能得出结论 $P(n)$。这是一个肯定结论的谬误。\par

    \textbf{示例2：}\par
    命题：如果 $n$ 不是正数，则 $n^2$ 不是正数\par
    证明：假定 $n$ 不是正数。因为命题“如果 $n$ 是正数，则 $n^2$ 是正数”为真，所以 $n^2$ 不是正数。\par
    错误：从条件语句 $\forall n (P(n) \rightarrow Q(n))$ 和前提 $\neg P(n)$ 不能得出结论 $\neg Q(n)$。这是一个否定假设的谬误。\par

    \textbf{示例3：}\par
    命题：如果 $n^2$ 是偶数，则 $n$ 是偶数\par
    证明：假定 $n^2$ 是偶数。那么存在某个整数 $k$ 使得 $n^2 = 2k$。令 $n = 2r$，其中 $r$ 为某个整数。这证明了 $n$ 是偶数。\par
    错误：证明中没有任何论证（包括前提和推理规则）可以得出语句“$n = 2r$，其中 $r$ 为某个整数”为真。这是一个窃取论题的谬误（the fallacy of begging the question），也称为循环推理（circular reasoning）或者循环论证。\par
\end{definition}

\subsection{证明的方法和策略}

\subsubsection{分情形证明法}

\paragraph{分情形证明法}

\begin{definition}
    \textbf{分情形证明法（proof by cases）}\par
    有时候采用单一的论证不能在定理的所有可能情况下都成立\par
    分情形证明法就是分别考虑不同的情况来证明定理\par
    如果前提 $p$ 等价于 $p_1 \lor p_2 \lor \cdots \lor p_n$\par
    即前提可以分为 $n$ 种情形，不同情形间可以有重叠，但一定要覆盖所有可能的情况\par
    利用等价式\par
    $p_1 \lor p_2 \lor \cdots \lor p_n \rightarrow q \equiv (p_1 \rightarrow q) \land (p_2 \rightarrow q) \land \cdots \land (p_n \rightarrow q)$\par
    只需要证明对每个 $i$ 条件语句 $p_i \rightarrow q$ 都为真，即可证明 $p \rightarrow q$\par

    \textbf{何时采用分情形证明法？}\par
    \begin{itemize}
        \item 当一个证明不可能兼顾所有情形
        \item 当每一个情形的额外信息有助于推动证明
    \end{itemize}

    \textbf{示例1：}\par
    证明“如果 $n$ 为整数，则有 $n^2 \geq n$\par
    \begin{itemize}
        \item 情形1：$n = 0$，有 $n^2 = 0 \geq n$
        \item 情形2：$n \geq 1$，把不等式 $n \geq 1$ 两侧同乘 $n$ 可得 $n^2 \geq n$
        \item 情形3：$n \leq -1$，有 $n^2 \geq 0 > n$
    \end{itemize}

    \textbf{示例2：}\par
    定义 $a@b = \max\{a, b\}$\par
    证明 @ 运算符的结合律，即对于实数 $a, b, c$ 有 $a@(b@c) = (a@b)@c$\par
    对于任意实数 $a, b, c$ 以下 6 种情形之一必定成立：\par
    \begin{itemize}
        \item $a \geq b \geq c$
        \item $a \geq c \geq b$
        \item $b \geq a \geq c$
        \item $b \geq c \geq a$
        \item $c \geq a \geq b$
        \item $c \geq b \geq a$
    \end{itemize}

    分情形证明：\par
    \begin{itemize}
        \item $a \geq b \geq c$，则 $a@(b@c) = a@c = a$，$(a@b)@c = a@b = a$，等式成立
        \item $a \geq c \geq b$，则 $a@(b@c) = a@c = a$，$(a@b)@c = a@c = a$，等式成立
        \item $b \geq a \geq c$，则 $a@(b@c) = b@c = b$，$(a@b)@c = a@b = b$，等式成立
        \item $b \geq c \geq a$，则 $a@(b@c) = b@c = b$，$(a@b)@c = a@b = b$，等式成立
        \item $c \geq a \geq b$，则 $a@(b@c) = a@c = c$，$(a@b)@c = a@c = c$，等式成立
        \item $c \geq b \geq a$，则 $a@(b@c) = b@c = c$，$(a@b)@c = a@c = c$，等式成立
    \end{itemize}
    所以命题“对于实数 $a, b, c$ 有 $a@(b@c) = (a@b)@c$”为真\par
\end{definition}

\paragraph{不失一般性}

\begin{definition}
    \textbf{不失一般性（without loss of generality，WLOG）}\par
    在分情形证明中，只需要给出一种情形下的论证\par
    其他一系列情形的论证可以通过对该情形的论证作简单的修改或者补充来完成\par
    引入“不失一般性”概念后，可以缩短证明篇幅，分情形证明法更加有效\par
    但是，不正确地应用“不失一般性”会导致错误\par
    \begin{itemize}
        \item 有时候论证中做的假设会导致失去一般性
        \item 有的情形可能与其他情形有着巨大的差异
    \end{itemize}

    \textbf{示例：}\par
    证明“如果 $x$ 和 $y$ 是整数而且 $xy$ 和 $x + y$ 都是偶数，则 $x$ 和 $y$ 也是偶数”\par
    使用反证法，假设 $x$ 和 $y$ 不都是偶数，即 $x$ 和 $y$ 中至少有一个是奇数\par
    不失一般性，假设 $x$ 为奇数，则存在整数 $n$ 使得 $x = 2n + 1$\par
    \begin{itemize}
        \item 如果 $y$ 为偶数，则存在整数 $m$ 使得 $y = 2m$，那么 $x + y = 2n + 1 + 2m = 2(m + n) + 1$，即 $x + y$ 为奇数，矛盾
        \item 如果 $y$ 为奇数，则存在整数 $m$ 使得 $y = 2m + 1$，那么 $xy = (2n + 1)(2m + 1) = 4mn + 2m + 2n + 1 = 2(2mn + m + n) + 1$，即 $xy$ 为奇数，矛盾
    \end{itemize}
    这里只考虑 $x$ 为奇数的情形，是因为 $y$ 为奇数的情形只需把上面的论证过程中的符号 $x$ 和 $y$ 互换即可。这就是不失一般性的含义。\par
\end{definition}

\paragraph{穷举证明法}

\begin{definition}
    \textbf{穷举证明法（exhaustive proof，proof by exhaustion）}\par
    分情形证明法的一个特例\par
    每个情形涉及检验一个具体的例子\par
    通过穷尽所有可能的例子来证明\par
    当需要验证的例子较少时可行\par

    \textbf{示例：}\par
    证明不超过100的连续正整数同时是幂次数的只有 8 和 9\par
    从 1 到 100 逐个检查 $n$ 是否幂次数，如果是，再检查 $n + 1$ 是否幂次数\par
\end{definition}

\subsection{存在性证明}

\begin{definition}
    \textbf{存在性证明（existence proof）}\par
    许多定理是断言特定类型对象的存在性，形如 $\exists x P(x)$\par
    存在性证明可以分为两种\par
    \begin{itemize}
        \item 构造性证明
        \item 非构造性证明
    \end{itemize}
\end{definition}

\subsubsection{构造性证明}

\begin{definition}
    \textbf{构造性证明（constructive proof）}\par
    找出一个元素 $c$ 使得 $P(c)$ 为真\par
    通过存在引入证明 $\exists x P(x)$ 为真\par
    元素 $c$ 称为 $\exists x P(x)$ 的一个物证（witness）\par

    \textbf{示例：}\par
    证明存在一个整数，可以用两种不同的方式将其表示为正整数的立方和\par
    经过计算搜索可找到 $1729 = 10^3 + 9^3 = 12^3 + 1^3$\par
\end{definition}

\subsubsection{非构造性证明}

\begin{definition}
    \textbf{非构造性证明（nonconstructive proof）}\par
    不需要找出使 $P(c)$ 为真的具体元素 $c$\par
    \begin{itemize}
        \item 归谬证明法：假设不存在一个元素 $c$ 可以使 $P(c)$ 为真，推导出矛盾式
        \item 概率法：证明使得 $P(c)$ 为真的元素 $c$ 出现的概率大于零
    \end{itemize}

    \textbf{示例：}\par
    证明“存在无理数 $x$ 和 $y$ 使得 $x^y$ 是有理数”\par
    假设命题为假。因为 $\sqrt{2}$ 为无理数，根据假设，$\sqrt{2}^{\sqrt{2}}$ 是无理数。\par
    令 $x = \sqrt{2}^{\sqrt{2}}$，$y = \sqrt{2}$，则 $x^y = (\sqrt{2}^{\sqrt{2}})^{\sqrt{2}} = \sqrt{2}^2 = 2$，与假设矛盾。\par
\end{definition}

\subsection{唯一性证明}

\begin{definition}
    \textbf{唯一性证明（uniqueness proof）}\par
    有的定理断言特定类型对象存在而且唯一，形如 $\exists! x P(x)$\par
    唯一性证明通常由两部分构成：\par
    \begin{itemize}
        \item 存在性：证明存在一个元素 $x$ 使得 $P(x)$ 为真
        \item 唯一性：证明对任意元素 $y \neq x$ 都有 $P(y)$ 为假
    \end{itemize}
    原理是等价式\par
    $\exists! x P(x) \equiv \exists x (P(x) \land \forall y (y \neq x \rightarrow \neg P(y)))$\par
    构造性证明 vs 非构造性证明\par

    \textbf{示例：}\par
    证明“如果 $a$ 和 $b$ 是实数且 $a \neq 0$，那么存在唯一的实数 $r$ 使得 $ar + b = 0$\par
    \begin{itemize}
        \item 存在性：\par
        令 $r = -\frac{b}{a}$，则 $ar + b = a \left(-\frac{b}{a}\right) + b = -b + b = 0$
        \item 唯一性：\par
        假设实数 $s$ 使得 $as + b = 0$，则 $as + b = 0 = ar + b$，因为 $a \neq 0$，所以 $s = r$\par
        即 $as + b = 0 \rightarrow s = r$ 为真\par
        那么逆否命题 $s \neq r \rightarrow as + b \neq 0$ 为真\par
    \end{itemize}
\end{definition}

\subsection{证明策略}

\begin{definition}
    \textbf{正向推理（forward reasoning）}\par
    从已知前提出发，逐步推理，最终得到需要的结论\par
    例如为了证明 $p \rightarrow q$，\par
    \begin{itemize}
        \item 从 $p$ 出发逐步推理得到 $q$ （直接证明法）
        \item 也可以从 $\neg q$ 出发逐步推理得到 $\neg p$ （反证法）
    \end{itemize}

    \textbf{反向推理（backward reasoning）}\par
    从需要的结论出发，反向逐步寻找可以推理得到结论的前提\par
    例如为了证明 $p \rightarrow q$，\par
    \begin{itemize}
        \item 从 $q$ 出发寻找使得 $r_1 \rightarrow q$ 为真的命题 $r_1$
        \item 再寻找使得 $r_2 \rightarrow r_1$ 为真的命题 $r_2$
        \item 逐步进行直至某个 $r_i = p$
    \end{itemize}
    反向推理不等于反证法\par
    反向推理得到论证过程后，描述证明过程仍然要用正向推理\par

    \textbf{示例：}\par
    假定两人玩游戏，轮流从最初有 15 块石头的堆中每次取 1、2 或 3 块石头，取到最后一块石头的人获胜。证明无论第二个玩家怎么取，第一个玩家都能赢得游戏。\par
    正向推理无从下手\par
    反向推理：\par
    \begin{itemize}
        \item 假设游戏一共进行了 $n$ 步
        \item 第 $n$ 步：轮到第一个玩家（甲）取，如果堆里剩下 1-3 块石头，甲赢
        \item 第 $n - 1$ 步：轮到第二个玩家（乙）取，如果堆里剩下 4 块石头，无论乙怎么取，必然剩下 1-3 块石头
        \item 第 $n - 2$ 步：轮到甲取，如果堆里剩下 5-7 块石头，甲可以取得只剩 4 块石头
        \item 第 $n - 3$ 步：轮到乙取，如果堆里剩下 8 块石头，无论乙怎么取，必然剩下 5-7 块石头
        \item 第 $n - 4$ 步：轮到甲取，如果堆里剩下 9-11 块石头，甲可以取得只剩 8 块石头
        \item 第 $n - 5$ 步：轮到乙取，如果堆里剩下 12 块石头，无论乙怎么取，必然剩下 9-11 块石头
        \item 第 $n - 6$ 步：轮到甲取，甲可以取走 3 块剩下 12 块石头
    \end{itemize}
    将反向推理过程倒过来，即可得到正向推理\par
    \begin{itemize}
        \item 甲第一次取 3 块石头，使得堆里剩下 12 块石头
        \item 后面每次乙取完后，甲取石头使得堆里剩下 4 的倍数块石头
        \item 则无论乙怎么取，甲一定能获胜
    \end{itemize}

    \textbf{借鉴现有证明}\par
    在寻找证明方法时，从类似结论的现有证明中借鉴方法是一个很好的思路\par
    一个现有证明通常可以改编用于证明其他类似结论\par
    即使不完全一致，现有证明中的一些想法也可能有所帮助\par

    \textbf{寻找反例}\par
    面对一个猜想，可以尝试去用各种方法去证明猜想\par
    当所有努力都失败了，可以尝试寻找反例，如果找不到再尝试证明\par
    寻找反例通常能提供对问题的理解和领悟\par
\end{definition}



\chapter{基本结构：集合、函数、序列、求和与矩阵}\thispagestyle{fancy} 

\section{集合}

\subsection{集合的定义}

\begin{definition}
    本课程中不使用形式化集合论，而是使用朴素集合论（naïve set theory）\par
    \textbf{集合}\par
    集合是一个由不同对象构成的无序群体\par
    对象称为集合的元素（element）或成员（member）\par
    通常用大写字母表示集合，小写字母表示集合中的元素\par
\end{definition}

\subsection{集合的表示}

\begin{definition}
    \textbf{花名册方法（roster method）}\par

    \textbf{集合构造器（set builder）}\par
    通过描述作为集合的元素所必须具有的性质来刻画集合\par
    使用记号 $ \{ x \mid x \text{ 具有性质 } P \} $，读作“满足 $P$ 的所有 $x$ 的集合”\par
\end{definition}

\subsection{特殊的集合}

\begin{definition}
    \textbf{一些常见的重要集合：}\par
    \begin{itemize}
        \item $\mathbb{N} = \{0, 1, 2, 3, \ldots\}$，所有自然数的集合
        \item $\mathbb{Z} = \{\ldots, -3, -2, -1, 0, 1, 2, 3, \ldots\}$，所有整数的集合
        \item $\mathbb{Z}^+ = \{1, 2, 3, \ldots\}$，所有正整数的集合
        \item $\mathbb{Z}^- = \{-1, -2, -3, \ldots\}$，所有负整数的集合
        \item $\mathbb{Q} = \left\{ \frac{p}{q} \mid p \in \mathbb{Z}, q \in \mathbb{Z}, q \neq 0 \right\}$，所有有理数的集合
        \item $\mathbb{R}$，所有实数的集合
        \item $\mathbb{R}^+$，所有正实数的集合
        \item $\mathbb{C}$，所有复数的集合
    \end{itemize}

    集合的元素可以是其他集合\par
    例如，集合 $\{\mathbb{N}, \mathbb{Z}, \mathbb{Q}, \mathbb{R}\}$ 包含了四个元素：\par
    \begin{itemize}
        \item $\mathbb{N}$ 自然数集
        \item $\mathbb{Z}$ 整数集
        \item $\mathbb{Q}$ 有理数集
        \item $\mathbb{R}$ 实数集
    \end{itemize}

    注意不要混淆\par
    \begin{itemize}
        \item 空集 $\emptyset$
        \item 单元素集 $\{\emptyset\}$
    \end{itemize}
\end{definition}

\subsection{集合的相等}

\begin{definition}
    \textbf{集合相等}\par
    两个集合相等（equal），当且仅当这两个集合包含相同的元素\par
    假设 $A$ 和 $B$ 是相等的两个集合，那么记为 $A = B$\par
    $A = B$ 当且仅当 $\forall x (x \in A \leftrightarrow x \in B)$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $\{1, 2, 3, 4, 5\} = \{5, 1, 2, 4, 3\}$
        \item $\{1, 2, 2, 2, 3, 3, 3, 3\} = \{1, 2, 3\}$
        \item $\{1, 2, 3, \ldots, 99\} = \{x \mid x \in \mathbb{Z}^+, x < 100\}$
    \end{itemize}
\end{definition}

\subsection{朴素集合论}

\begin{definition}
    \textbf{悖论（paradox）}\par

    \textbf{罗素悖论（Russell Paradox）}\par
    定义集合 $S$ 为“所有不包含自身的集合”构成的集合，那么是否 $S \in S$ 呢？\par
    \begin{itemize}
        \item 如果 $S \in S$，则 $S$ 不是“不包含自身的集合”，不应该是 $S$ 的成员，矛盾
        \item 如果 $S \notin S$，则 $S$ 是“不包含自身的集合”，应该是 $S$ 的成员，矛盾
    \end{itemize}

    \textbf{理发师悖论}\par
    小镇上有一位理发师，他声称自己给“所有不给自己理发的人”理发。\par
    那么这名理发师是否该给他自己理发呢？\par

    \textbf{朴素集合论}\par
    朴素集合论是最早发展的集合论，由数学家格奥尔格·康托尔提出\par
    “朴素”是指一个非形式化的理论\par
    即用自然语言来描述集合以及集合的运算\par
    朴素集合论中对构建集合的对象及性质没有任何限制\par
    \begin{itemize}
        \item 公理化集合论可以避免悖论
        \item 朴素集合论需要在可形成集合的条件上作一些限制，以避免悖论
        \item 常见的集合都可以用朴素集合论处理
    \end{itemize}
\end{definition}

\subsection{Venn 图}

\begin{definition}
    \textbf{Venn图（文氏图，韦恩图）}\par
    以英国数学家John Venn名字命名\par
    常用于表示集合之间的关系\par
    用矩形框表示全集\par
    在矩形框内部，用圆形或者其他几何图形表示集合\par
    有时候用点表示集合中特定的元素\par
\end{definition}

\subsection{集合的子集}

\begin{definition}
    \textbf{子集（subset）}\par
    集合 $A$ 是集合 $B$ 的子集，当且仅当 $A$ 的每一个元素都是 $B$ 的元素\par
    如果集合 $A$ 是集合 $B$ 的子集，则称 $B$ 是 $A$ 的超集（superset）\par

    \textbf{证明 $A \subseteq B$}\par
    需要证明：如果 $x \in A$，则 $x \in B$\par
    $\forall x (x \in A \rightarrow x \in B)$\par

    \textbf{证明 $A \nsubseteq B$}\par
    需要找到一个 $x \in A$ 使得 $x \notin B$\par
    $\neg \forall x (x \in A \rightarrow x \in B) \equiv \exists x (x \in A \land x \notin B)$\par

    用记号 $A \subset B$ 表示 $A$ 是 $B$ 的真子集\par
\end{definition}

\subsection{集合的大小}

\begin{definition}
    \textbf{集合的大小}\par
    如果集合 $S$ 中恰好有 $n$ 个不同的元素，这里 $n$ 为非负整数，则称 $S$ 是有限的，否则称 $S$ 是无限的\par
    一个有限集 $A$ 中不同元素的个数，称为集合 $A$ 的基数（set cardinality）\par
    用记号 $|A|$ 表示集合 $A$ 的基数\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $|\emptyset| = 0$
        \item $|\{\emptyset\}| = 1$
        \item $|\{1, 2, 3\}| = 3$
    \end{itemize}
\end{definition}

\subsection{幂集}

\begin{definition}
    \textbf{幂集（power set）}\par
    集合 $S$ 的所有子集构成的集合，称为 $S$ 的幂集\par
    常用 $\mathcal{P}(S)$ 表示集合 $S$ 的幂集\par
    如果 $|S| = n$ 则 $|\mathcal{P}(S)| = 2^n$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $\mathcal{P}(\{a, b\}) = \{\emptyset, \{a\}, \{b\}, \{a, b\}\}$
        \item $\mathcal{P}(\emptyset) = \{\emptyset\}$
    \end{itemize}
\end{definition}

\subsection{笛卡尔积}

\begin{definition}
    \textbf{有序n元组（ordered n-tuple）}\par
    有时候集合中的元素顺序是很重要的\par
    有序n元组是由 $n$ 个对象组成的有序集合 $(a_1, a_2, a_3, \ldots, a_n)$，其中 $a_1$ 为第 1 个元素，$a_2$ 为第 2 个元素，如此类推，$a_n$ 为第 $n$ 个元素\par
    两个有序n元组相等，当且仅当对应位置的元素都相等\par

    \textbf{序偶（ordered pair）}\par
    有序2元组又称序偶或有序对\par
    序偶 $(a, b)$ 和 $(c, d)$ 相等，当且仅当 $a = c$ 且 $b = d$\par

    \textbf{笛卡尔积（Cartesian Product）}\par
    两个集合 $A$ 和 $B$ 的笛卡尔积是由序偶 $(a, b)$ 构成的集合，其中 $a \in A, b \in B$\par
    用记号 $A \times B$ 表示集合 $A$ 和 $B$ 的笛卡尔积\par
    $A \times B = \{(a, b) \mid a \in A, b \in B\}$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $A = \{a, b\}$，$B = \{1, 2, 3\}$
        \item $A \times B = \{(a, 1), (a, 2), (a, 3), (b, 1), (b, 2), (b, 3)\}$
    \end{itemize}

    笛卡尔积 $A \times B$ 的一个子集 $R$ 被称为从集合 $A$ 到 $B$ 的关系（relation）\par

    \textbf{多个集合的笛卡尔积}\par
    $n$ 个集合 $A_1, A_2, \ldots, A_n$ 的笛卡尔积是由有序n元组 $(a_1, a_2, \ldots, a_n)$ 构成的集合，其中 $a_i \in A_i, i = 1, 2, \ldots, n$\par
    $A_1 \times A_2 \times \ldots \times A_n = \{(a_1, a_2, \ldots, a_n) \mid a_i \in A_i, i = 1, 2, \ldots, n\}$\par
    用记号 $A^2$ 表示 $A \times A$，$A^3$ 表示 $A \times A \times A$，以此类推\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $A = \{0, 1\}$，$B = \{1, 2\}$，$C = \{1, 2, 3\}$
        \item $A \times B \times C = \{(0, 1, 1), (0, 1, 2), (0, 1, 3), (0, 2, 1), (0, 2, 2), (0, 2, 3), (1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2), (1, 2, 3)\}$
    \end{itemize}
\end{definition}

\subsection{量词中的集合记号}

\begin{definition}
    集合符号经常用于限定域量化语句\par
    \begin{itemize}
        \item $\forall x \in S \, P(x)$ 表示 $P(x)$ 在 $S$ 的所有元素上的全称量化
        \item $\exists x \in S \, P(x)$ 表示 $P(x)$ 在 $S$ 的所有元素上的存在量化
        \item $\forall x \in S \, P(x) \iff \forall x (x \in S \rightarrow P(x))$
        \item $\exists x \in S \, P(x) \iff \exists x (x \in S \land P(x))$
    \end{itemize}

    \textbf{示例：}\par
    $\forall x \in \mathbb{R} \, (x^2 \geq 0)$\par
\end{definition}

\subsection{真值集}

\begin{definition}
    \textbf{真值集（truth set）}\par
    给定一个谓词 $P$ 和论域 $D$，定义 $P$ 的真值集为 $D$ 中使得 $P(x)$ 为真的元素 $x$ 构成的集合\par
    $P$ 的真值集记为 $\{x \in D \mid P(x)\}$\par

    \textbf{量词与真值集}\par
    \begin{itemize}
        \item $\forall x P(x)$ 在论域 $D$ 上为真，当且仅当 $P$ 的真值集为 $D$
        \item $\exists x P(x)$ 在论域 $D$ 上为真，当且仅当 $P$ 的真值集非空
    \end{itemize}

    \textbf{示例：}\par
    设论域为整数集\par
    \begin{itemize}
        \item $P(x)$ 为“$x^2 = 1$”，其真值集 $\{x \in \mathbb{Z} \mid x^2 = 1\} = \{-1, 1\}$
        \item $Q(x)$ 为“$x^2 = 2$”，其真值集 $\{x \in \mathbb{Z} \mid x^2 = 2\} = \emptyset$
        \item $R(x)$ 为“$x = x$”，其真值集 $\{x \in \mathbb{Z} \mid x = x\} = \mathbb{Z}$
    \end{itemize}
\end{definition}

\section{集合运算}

\subsection{集合的运算}

\begin{definition}
    \textbf{差集（difference）}\par
    集合 $A$ 和 $B$ 的差集是一个集合，包含在 $A$ 中但不在 $B$ 中的元素\par
    有时候也称为集合 $B$ 相对于 $A$ 的补集\par
    用记号 $A - B$ 表示集合 $A$ 和 $B$ 的差集，有时候也记为 $A \setminus B$\par
    $A - B = \{x \mid x \in A \land x \notin B\}$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $A = \{1, 2, 3\}$，$B = \{3, 4, 5\}$
        \item $A - B = \{1, 2\}$
    \end{itemize}

    \textbf{补集（complement）}\par
    集合 $A$ 的补集是一个集合，包含在全集 $U$ 中但不在 $A$ 中的元素\par
    补集的定义取决于全集，因此有时明确写为 $A$ 相对于全集 $U$ 的补集\par
    用记号 $A^c$ 表示集合 $A$ 的补集，有时候也记为 $\overline{A}$\par
    $A^c = \{x \in U \mid x \notin A\} = U - A$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $A = \{1, 2, 3\}$，$U = \{1, 2, 3, 4, 5\}$
        \item $A^c = \{4, 5\}$
    \end{itemize}

    \textbf{对称差（symmetric difference）}\par
    集合 $A$ 和 $B$ 的对称差是一个集合，包含在 $A$ 或 $B$ 中但不同时在 $A$ 和 $B$ 中的元素\par
    用记号 $A \oplus B$ 表示集合 $A$ 和 $B$ 的对称差\par
    $A \oplus B = \{x \mid (x \in A \land x \notin B) \lor (x \in B \land x \notin A)\} = (A - B) \cup (B - A)$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $A = \{1, 2, 3\}$，$B = \{3, 4, 5\}$
        \item $A \oplus B = \{1, 2, 4, 5\}$
    \end{itemize}
\end{definition}

\subsection{集合恒等式}

\begin{definition}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{eq.png}
    \end{figure}
    \textbf{集合恒等式}\par
    与逻辑等价式类似：\par
    \begin{itemize}
        \item 并集 vs 析取： $A \cup B = \{x \mid x \in A \lor x \in B\}$
        \item 交集 vs 合取： $A \cap B = \{x \mid x \in A \land x \in B\}$
        \item 补集 vs 否定： $A^c = \{x \mid x \notin A\}$
        \item 全集 vs 永真式： $U = \{x \mid x \in U\}$
        \item 空集 vs 矛盾式： $\emptyset = \{x \mid x \notin U\}$
    \end{itemize}
    两者都是布尔代数恒等式的特例\par

    \textbf{集合恒等式的证明方法}\par
    \begin{itemize}
        \item 子集方法：证明恒等式每一边的集合是另一边的子集
        \item 命题逻辑方法：利用集合构造器和命题逻辑推理规则
        \item 成员表方法：对于原子集合的每一种可能组合，证明恰好属于这个组合的元素要么同时属于恒等式两边的集合，要么都不属于
        \item 应用已知的恒等式：从恒等式的一边开始，通过应用一系列已经建立的恒等式将它转换成另一边的形式
    \end{itemize}

    \textbf{示例1：}\par
    证明德·摩根律 $(A \cap B)^c = A^c \cup B^c $\par
    \begin{itemize}
        \item 证明德·摩根律 $(A \cap B)^c = A^c \cup B^c $\par

\textbf{子集方法：}\par
\begin{itemize}
    \item $(A \cap B)^c \subseteq A^c \cup B^c$：假设 $x \in (A \cap B)^c$，根据补集定义，$x \notin A \cap B$，由交集定义，$x$ 不同时属于集合 $A$ 和 $B$，那么 $x$ 不属于 $A$ 或者不属于 $B$，根据补集定义这意味着，$x$ 属于 $A^c$ 或者属于 $B^c$，根据并集定义，有 $x \in A^c \cup B^c$
    \item $A^c \cup B^c \subseteq (A \cap B)^c$：假设 $x \in A^c \cup B^c$，根据并集定义，$x$ 属于 $A^c$ 或者属于 $B^c$，根据补集定义这意味着，$x$ 不属于 $A$ 或者不属于 $B$，即 $x$ 不同时属于集合 $A$ 和 $B$，由交集定义，$x \notin A \cap B$，根据补集定义，有 $x \in (A \cap B)^c$
\end{itemize}

\textbf{集合构造器和逻辑等价式方法：}\par
\begin{align*}
    (A \cap B)^c &= \{x \mid x \notin A \cap B\} \quad \text{补集的定义} \\
    &= \{x \mid \neg (x \in A \cap B)\} \quad \text{不属于符号的定义} \\
    &= \{x \mid \neg (x \in A \land x \in B)\} \quad \text{交集的定义} \\
    &= \{x \mid \neg (x \in A) \lor \neg (x \in B)\} \quad \text{德·摩根律} \\
    &= \{x \mid x \notin A \lor x \notin B\} \quad \text{不属于符号的定义} \\
    &= \{x \mid x \in A^c \lor x \in B^c\} \quad \text{补集的定义} \\
    &= \{x \mid x \in A^c \cup B^c\} \quad \text{并集的定义} \\
    &= A^c \cup B^c \quad \text{集合构造器}
\end{align*}
        \item 成员表方法：
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.8\textwidth]{set-identity.png}
        \end{figure}
    \end{itemize}

\end{definition}

\subsection{多重集}

\begin{definition}
    \textbf{多重集（multiset）}\par
    有时候元素在集合中出现的次数是有意义的\par
    多重集是一个无序集合，其中元素可以出现多于一次\par
    可以用集合记号来表示多重集，但需要注明以避免与集合混淆产生二义性\par
    可以用记号 $\{m_1 \cdot a_1, m_2 \cdot a_2, \ldots, m_n \cdot a_n\}$，其中 $m_i$ 称为元素 $a_i$ 的重数（multiplicity），重数为 0 表示该集合不包含这个元素\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $\{a, a, b, b, b, c\}$
        \item $\{2 \cdot a, 3 \cdot b, 1 \cdot c\}$
    \end{itemize}

    \textbf{多重集运算}\par
    \begin{itemize}
        \item 基数：多重集中所有元素的重数的总和
        \item 并集：一个多重集，其中元素的重数是它在两个多重集中重数的最大值
        \item 交集：一个多重集，其中元素的重数是它在两个多重集中重数的最小值
        \item 差集：一个多重集，其中元素的重数是它在两个多重集中重数的差，如果差是负数则重数为 0
        \item 和集：一个多重集，其中元素的重数是它在两个多重集中重数的和
        \item 集合是元素重数只能为 1 或 0 的多重集，此时多重集的并集、交集、差集的定义和集合运算的定义一致
    \end{itemize}

    \textbf{示例：}\par
    \begin{itemize}
        \item $P = \{4 \cdot a, 1 \cdot b, 3 \cdot c\}$
        \item $Q = \{3 \cdot a, 4 \cdot b, 2 \cdot d\}$
        \item $P \cup Q = \{4 \cdot a, 4 \cdot b, 3 \cdot c, 2 \cdot d\}$
        \item $P \cap Q = \{3 \cdot a, 1 \cdot b, 0 \cdot c, 0 \cdot d\} = \{3 \cdot a, 1 \cdot b\}$
        \item $P - Q = \{1 \cdot a, 0 \cdot b, 3 \cdot c, 0 \cdot d\} = \{1 \cdot a, 3 \cdot c\}$
        \item $P + Q = \{7 \cdot a, 5 \cdot b, 3 \cdot c, 2 \cdot d\}$
    \end{itemize}
\end{definition}

\section{函数}

\begin{definition}
    \textbf{函数（function）}\par
    \begin{itemize}
        \item 给定一个函数 $f: A \to B$
        \begin{itemize}
            \item 我们说 $f$ 把 $A$ 映射到 $B$，或者说 $f$ 是从 $A$ 到 $B$ 的映射
            \item $A$ 称为 $f$ 的定义域（domain）
            \item $B$ 称为 $f$ 的陪域（codomain）
            \item 如果 $f(a) = b$，称 $b$ 是 $a$ 的像（image），$a$ 是 $b$ 的原像（preimage）
            \item $f$ 的值域（range）是所有 $A$ 中元素的像的集合，记为 $f(A)$
            \item 陪域是函数的可能值的集合，值域总是陪域的子集
            \item 程序语言中的函数：定义域-输入参数类型，陪域-返回值类型
        \end{itemize}
    \end{itemize}
\end{definition}

\subsection{函数的表示}

\begin{definition}
    \textbf{满射函数（surjection）}\par
    映上的（onto）\par

    \textbf{双射函数（bijection）}\par
    一一对应的（one-to-one correspondence）\par

    \textbf{单射函数（injection）}\par
    是一对一的（one-to-one）\par

    \textbf{逆函数（inverse function）}\par
    反函数\par

    \textbf{复合函数（composition）}\par
\end{definition}

\subsection{函数的图（Graph of Function）}

\begin{definition}
    函数 $f: A \to B$ 的图是序偶集合 $\{(a, b) \mid a \in A \land f(a) = b\}$\par
\end{definition}

\subsection{一些重要的函数}

\begin{definition}
    \textbf{下取整函数（floor function）}\par
    $f: \mathbb{R} \to \mathbb{Z}$，指派给实数 $x$ 小于或等于 $x$ 的最大整数，记为 $\lfloor x \rfloor$\par

    \textbf{上取整函数（ceiling function）}\par
    $f: \mathbb{R} \to \mathbb{Z}$，指派给实数 $x$ 大于或等于 $x$ 的最小整数，记为 $\lceil x \rceil$\par

    \textbf{示例：}\par
    \begin{itemize}
        \item $\lfloor 3.5 \rfloor = 3$，$\lfloor -1.5 \rfloor = -2$
        \item $\lceil 3.5 \rceil = 4$，$\lceil -1.5 \rceil = -1$
    \end{itemize}

    \textbf{多项式函数（polynomial function）}\par
    $f(x) = a_n x^n + a_{n-1} x^{n-1} + \cdots + a_2 x^2 + a_1 x + a_0$\par

    \textbf{指数函数（exponential function）}\par
    $f(x) = b^x$，$b \in \mathbb{R}^+$\par

    \textbf{对数函数（logarithmic function）}\par
    $f(x) = \log_b x$，$b \in \mathbb{R}^+$，$b > 1$\par
    指数函数的逆函数\par
    常用 $\log x$ 表示 $\log_2 x$\par

    \textbf{阶乘函数（factorial function）}\par
    $f: \mathbb{N} \to \mathbb{Z}^+$，$f(n) = n! = 1 \times 2 \times \cdots \times (n-1) \times n$，$f(0) = 0! = 1$\par
    斯特林公式（Stirling’s formula）：$n! \sim \sqrt{2\pi n} \left(\frac{n}{e}\right)^n$\par
    符号 $\sim$ 读作“渐进于”，$f(n) \sim g(n)$ 表示 $\lim_{n \to \infty} \frac{f(n)}{g(n)} = 1$\par
    $\lim_{n \to \infty} \frac{n!}{\sqrt{2\pi n} \left(\frac{n}{e}\right)^n} = 1$\par

    \textbf{示例：}\par
    $f(20) = 2432902008176640000$\par
\end{definition}

\subsection{部分函数}

\begin{definition}
    \textbf{部分函数（partial function）}\par
    \begin{itemize}
        \item 从集合 $A$ 到集合 $B$ 的部分函数 $f$ 是给 $A$ 的一个子集（称为 $f$ 的定义域）中的每个元素 $a$ 指派 $B$ 中唯一的元素 $b$
        \item 集合 $A$ 称为部分函数 $f$ 的域
        \item 集合 $B$ 称为部分函数 $f$ 的陪域
        \item 我们说 $f$ 对于在 $A$ 中但不在 $f$ 的定义域中的元素无定义（undefined）
        \item 当 $f$ 的定义域等于 $A$ 时，就说 $f$ 是全函数（total function）
    \end{itemize}
    \textbf{示例：}\par
    \begin{itemize}
        \item $f: \mathbb{Z} \to \mathbb{R}$，$f(n) = \sqrt{n}$ 是一个从 $\mathbb{Z}$ 到 $\mathbb{R}$ 的部分函数，对于负整数无定义
    \end{itemize}
\end{definition}

\section{序列与求和}

\subsection{序列}

\begin{definition}
    \textbf{序列是元素的有序列表}\par
    \begin{itemize}
        \item 1, 3, 5, 7, 9, \dots
        \item 0, 1, 1, 2, 3, 5, 8, \dots
        \item abcdabcdabc\dots
    \end{itemize}

    \textbf{序列（sequence）}\par
    \begin{itemize}
        \item 序列是一个从整数集的子集（通常是集合 $\{0,1,2,3, \ldots\}$ 或集合 $\{1,2,3,4, \ldots\}$）到一个集合 $S$ 的函数
        \item 用记号 $a_n$ 表示整数 $n$ 的像，称 $a_n$ 为序列的一个项（term）
        \item 令 $f: \{0,1,2,3, \ldots\} \to S$，$a_n = f(n)$
        \item 用记号 $a_n$ 表示一个序列
    \end{itemize}

    \textbf{示例：}\par
    \begin{itemize}
        \item 序列 $b_n$，其中 $b_n = \frac{1}{n}$，$n$ 从 1 开始，则该序列为 $1, \frac{1}{2}, \frac{1}{3}, \frac{1}{4}, \ldots$
    \end{itemize}
    
    \textbf{几何数列（geometric progression）}\par
    \begin{itemize}
        \item 又称等比数列，是如下形式的序列： $a, ar, ar^2, ar^3, \ldots, ar^n, \ldots$
        \item 其中初始项（initial term）$a$ 和公比（common ratio）$r$ 都是实数
        \item 几何数列是指数函数 $f(x) = ar^x$ 的离散版本
    \end{itemize}
    \textbf{示例（$n$ 从 0 开始）：}\par
    \begin{itemize}
        \item 序列 $a_n$，其中 $a_n = (-1)^n$，该序列为： $1, -1, 1, -1, 1, \ldots$
        \item 序列 $b_n$，其中 $b_n = 2 \cdot 5^n$，该序列为： $2, 10, 50, 250, 1250, \ldots$
        \item 序列 $c_n$，其中 $c_n = 6 \cdot \left(\frac{1}{3}\right)^n$，该序列为： $6, 2, \frac{2}{3}, \frac{2}{9}, \frac{2}{27}, \ldots$
    \end{itemize}

    \textbf{算术数列（arithmetic progression）}\par
    \begin{itemize}
        \item 又称等差数列，是如下形式的序列： $a, a + d, a + 2d, \ldots, a + nd, \ldots$
        \item 其中初始项 $a$ 和公差（common difference）$d$ 都是实数
        \item 算术数列是线性函数 $f(x) = a + dx$ 的离散版本
    \end{itemize}
    \textbf{示例（$n$ 从 0 开始）：}\par
    \begin{itemize}
        \item 序列 $a_n$，其中 $a_n = -1 + 4n$，该序列为： $-1, 3, 7, 11, 15, \ldots$
        \item 序列 $b_n$，其中 $b_n = 7 - 3n$，该序列为： $7, 4, 1, -2, -5, \ldots$
        \item 序列 $c_n$，其中 $c_n = 1 + 2n$，该序列为： $1, 3, 5, 7, 9, \ldots$
    \end{itemize}

    \textbf{串（string）}\par
    \begin{itemize}
        \item 串是一个有限序列，$n$ 个项的串列通常记为 $a_1a_2a_3 \ldots a_n$，其中 $a_i \in A$，$A$ 是一个有限集合，称为字母表（alphabet），其中的元素称为字符（character）
        \item 空串（empty string）是没有任何项的串，记作 $\lambda$
        \item 串的长度（length）是这个串的项数，空串的长度为 0
        \item 字符串、比特串在计算机科学中有非常重要的作用
    \end{itemize}
    \textbf{示例：}\par
    \begin{itemize}
        \item 串 abccd 的长度为 5
    \end{itemize}
\end{definition}

\subsection{递推关系}

\begin{definition}
    \textbf{递推关系（recurrence relation）}\par
    \begin{itemize}
        \item 关于序列 $a_n$ 的递推关系是一个等式，对所有满足 $n \geq n_0$ （$n_0$ 为一个非负整数）的整数 $n$，它把 $a_n$ 用序列中前面的项（即 $a_0, a_1, a_2, \ldots, a_{n-1}$）中的一项或多项来表示
        \item 如果一个序列的项满足递推关系，则称该序列为递推关系的一个解
        \item 一个序列的初始条件（initial conditions）指定了递推关系生效的首项（即 $a_{n_0}$）之前的那些项
        \item 一个递推关系和初始条件唯一确定了一个序列
    \end{itemize}

    \textbf{斐波那契数列（Fibonacci sequence）}\par

    \textbf{求解递推关系}\par
    \begin{itemize}
        \item 为递推关系生成的序列的 $a_n$ 项找到一个公式
        \item 这个公式称为闭公式（closed formula）
        \item 在高级计数技术一章将介绍求解递推关系的几种方法
    \end{itemize}

    \textbf{迭代法（method of iteration）}\par
    \begin{itemize}
        \item 迭代或重复利用递推关系
        \item 正向替换（forward substitution）：从初始条件出发找到连续的项直到 $a_n$
        \item 反向替换（backward substitution）：从 $a_n$ 开始迭代直到可以用初始条件中的项（如 $a_0$）来表示
    \end{itemize}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{sum.png}
    \end{figure}
\end{definition}

\section{集合的基数}

\subsection{集合的基数}

\begin{definition}
    \textbf{集合的基数（cardinality）}\par
    \begin{itemize}
        \item 又称为集合的势，有限集合的基数是该集合中的元素个数
        \item 将有限集合的基数概念扩展到无穷集合，提供一个衡量两个集合相对大小的方法
        \item 集合 $A$ 的基数等于集合 $B$ 的基数，当且仅当存在一个从 $A$ 到 $B$ 的一一对应（双射函数），记作 $|A| = |B|$
        \item 如果存在一个从 $A$ 到 $B$ 的一对一（单射）函数，那么 $A$ 的基数小于或等于 $B$ 的基数，记作 $|A| \leq |B|$
        \item 当 $A \leq B$ 而且 $A$ 和 $B$ 有不同的基数时，我们说 $A$ 的基数小于 $B$ 的基数，记作 $|A| < |B|$
    \end{itemize}
\end{definition}

\subsection{可数集合}

\begin{definition}
    \textbf{可数集合（countable set）}\par
    \begin{itemize}
        \item 可数（countable）和不可数（uncountable）
        \begin{itemize}
            \item 如果一个集合是有限的或者和正整数集合（$\mathbb{Z}^+$）有相同的基数，则称这个集合是可数的
            \item 如果一个集合不是可数的，则称其为不可数的
            \item 当一个无穷集合是可数的（即可数无穷集合），它的基数为 $\aleph_0$
            \item $\aleph$ 读作阿列夫（aleph），是希伯来语（Hebrew）字母表的第一个字符
            \item 记作 $S = \aleph_0$，并说集合 $S$ 具有基数“阿列夫零（aleph null）”
        \end{itemize}
    \end{itemize}

    \textbf{证明一个集合是可数的}\par
    \begin{itemize}
        \item 一个无穷集合是可数的，当且仅当可以把集合中的元素排列成序列（以正整数为下标）
        \item 这是因为从正整数到集合 $S$ 的一一对应函数 $f$ 可以用序列 $a_1, a_2, \ldots, a_n, \ldots$ 表示，其中 $a_1 = f(1)$, $a_2 = f(2)$, $\ldots$, $a_n = f(n)$, $\ldots$
    \end{itemize}

    \textbf{示例1：}\par
    \begin{itemize}
        \item 证明正奇数集合是可数的
        \item 正奇数集合与正整数集合之间存在一一对应关系：$f(n) = 2n - 1$
    \end{itemize}

    \textbf{希尔伯特大饭店（Hilbert’s Grand Hotel）}\par
    \begin{itemize}
        \item 希尔伯特构造的一个例子，证明了某些对有限集合不可能的事情对于无穷集合变得可能
        \item 一个有可数无穷多个房间的大饭店，每个房间都住了客人，但是当一个新的客人来到这个大饭店，我们总是可以容纳这个新客人而不赶走旧的客人
        \item 当饭店的房间数量是有限时，所有房间客满的概念等价于不能再容纳新客人
        \item 但是房间数量是无穷时，这种等价关系不再成立
    \end{itemize}

    \textbf{示例2：}\par
    \begin{itemize}
        \item 证明所有整数的集合是可数的
        \item 我们可以把所有整数排列为一个序列：$0, 1, -1, 2, -2, 3, -3, \ldots$
        \item 这是一个双射函数 $f(n) = \begin{cases} 
            n^2 & \text{如果 } n \text{ 是偶数} \\
            -\frac{n-1}{2} & \text{如果 } n \text{ 是奇数}
        \end{cases}$
    \end{itemize}

    \textbf{示例3：}\par
    \begin{itemize}
        \item 证明正有理数集合是可数的
        \item 每个正有理数都可以表示为两个正整数之比 $\frac{p}{q}$
        \item 把有理数 $\frac{p}{q}$ 排在第 $q$ 行第 $p$ 列
        \item 从左上角出发，沿着每条反对角线依次列出相应的有理数
        \item 遇到已经列出过的有理数，就跳过不再重复列出
        \item 由于所有正有理数都被列出而且只列出一次
        \item 因此所有正有理数排列成了一个序列
    \end{itemize}

    \textbf{示例4：}\par
    \begin{itemize}
        \item 证明一个有限字母表 $A$ 上的有限串组成的集合 $S$ 是可数的
        \item 假设字母表 $A$ 中的字符有一个字母顺序
        \item 我们证明集合 $S$ 中的所有串可以排列成一个序列
        \begin{itemize}
            \item 先列出长度为 0 的串
            \item 再按字母顺序列出长度为 1 的串
            \item 再按字典序列出长度为 2 的串
            \item 以此类推
        \end{itemize}
        \item 这意味着存在一个从正整数到集合 $S$ 的一一对应，所以集合 $S$ 是可数的
    \end{itemize}

    \textbf{示例5：}\par
    \begin{itemize}
        \item 证明所有 Java 程序组成的集合是可数的
        \item 令 $A$ 为所有 Java 程序中允许出现的字符构成的字母表
        \item 令 $S$ 为字母表 $A$ 上的有限串集合
        \item 根据前一个示例，可以把 $S$ 中的串排列成一个序列 $a_n$
        \item 使用 Java 编译器按序列顺序，逐个检查字符串 $a_i$ 是否一个合法的 Java 程序
        \item 如果字符串 $a_i$ 通过 Java 编译器检查，则将其加入一个新的序列 $b_n$
        \item 通过以上过程，我们建立了一个从正整数到所有 Java 程序的一一对应
        \item 因此所有 Java 程序组成的集合是可数的
    \end{itemize}

    \textbf{子集的基数}\par
    \begin{itemize}
        \item 可数集合的子集是可数的
        \item 不可数集合的超集是不可数的
        \item 不可数集合一定存在可数无穷子集
    \end{itemize}

    \textbf{交集的基数}\par
    \begin{itemize}
        \item 可数集合与其他集合的交集是可数的
        \item 两个不可数集合的交集可能是可数的，也可能是不可数的
    \end{itemize}

    \textbf{并集的基数}\par
    \begin{itemize}
        \item 两个可数集合的并集是可数的
        \item 可数个可数集合的并集是可数的
        \item 不可数集合与其他集合的并集是不可数的
    \end{itemize}

    \textbf{差集的基数}\par
    \begin{itemize}
        \item 可数集合与其他集合的差集是可数的
        \item 不可数集合与可数集合的差集是不可数的
        \item 两个不可数集合的差集可能是可数的，也可能是不可数的
    \end{itemize}
\end{definition}



\subsection{不可数集合}

\begin{definition}
    \textbf{不可数集合（uncountable set）}\par
    \textbf{Schröder-Bernstein定理}\par
    \begin{itemize}
        \item 如果集合 $A$ 和 $B$ 满足 $|A| \leq |B|$ 和 $|B| \leq |A|$，那么 $|A| = |B|$
        \item 如果存在一个从集合 $A$ 到 $B$ 的单射 $f$ 和一个从集合 $B$ 到 $A$ 的单射 $g$，那么集合 $A$ 和 $B$ 是一一对应的。
    \end{itemize}

    \textbf{示例：}\par
    \begin{itemize}
        \item 证明 $[0,1] = [0,1)$
        \item 直接找一个从 $[0,1]$ 到 $[0,1)$ 的一一对应比较困难
        \item 因为 $[0,1) \subseteq [0,1]$，所以 $f(x) = x$ 是从 $[0,1)$ 到 $[0,1]$ 的单射
        \item 因为 $[0,0.5) \subseteq [0,1)$，所以 $g(x) = \frac{x}{2}$ 是从 $[0,1]$ 到 $[0,1)$ 的单射
    \end{itemize}

    \textbf{连续统假设（Continuum Hypothesis）}\par
    \begin{itemize}
        \item 连续统假设是关于无穷集合的基数的一个猜想
        \item 正整数集合的幂集与实数集具有相同的基数，即 $\mathcal{P}(\mathbb{Z}^+) = \mathbb{R} = c$
        \item 用 $2^S$ 表示集合 $S$ 的幂集的基数，因此 $c = \mathcal{P}(\mathbb{Z}^+) = 2^{\aleph_0}$
        \item 一个集合的基数总是小于它的幂集的基数，即 $S < \mathcal{P}(S) = 2^S$
        \item 连续统假设断言不存在集合 $A$ 使得 $\aleph_0 < |A| < 2^{\aleph_0}$
        \item 我们将无穷集合的基数从小到大排一个顺序 $\aleph_0 < \aleph_1 < \aleph_2 < \cdots$
        \item 如果连续统假设成立，则有 $\aleph_1 = c = 2^{\aleph_0}$
    \end{itemize}
\end{definition}

\subsection{可计算性}

\begin{definition}
    \textbf{可计算性（computability）}\par
    \begin{itemize}
        \item 我们说一个函数是可计算的（computable），如果存在一个（使用某种编程语言的）计算机程序可以找到这个函数的所有值
        \item 如果一个函数不是可计算的，那么我们说这个函数是不可计算的（uncomputable）
    \end{itemize}

    \textbf{存在不可计算的函数}\par
    \begin{itemize}
        \item 某种编程语言的所有程序集合是可数的
        \item 从一个可数无穷集合（如正整数集）到其自身的函数集合是不可数的
        \item 因此必然存在不可计算的函数
    \end{itemize}
\end{definition}

\section{矩阵}

\subsection{矩阵}

\begin{definition}
    
        \textbf{哈达玛积（Hadamard product）}\par
        \[
        A \circ B =
        \begin{bmatrix}
        a_{11}b_{11} & \cdots & a_{1n}b_{1n} \\
        \vdots & \ddots & \vdots \\
        a_{m1}b_{m1} & \cdots & a_{mn}b_{mn}
        \end{bmatrix}
        \]
        
        \textbf{克罗内克积（Kronecker product）}\par
        \[
        A \otimes B =
        \begin{bmatrix}
        a_{11}B & \cdots & a_{1n}B \\
        \vdots & \ddots & \vdots \\
        a_{m1}B & \cdots & a_{mn}B
        \end{bmatrix}
        \]
    
        \textbf{0-1矩阵（zero-one matrix）}\par
        \begin{itemize}
            \item 如果一个矩阵的元素是 0 或 1，称这个矩阵为 0-1矩阵
            \item 许多离散结构经常表示为 0-1矩阵
        \end{itemize}
        \textbf{布尔算术（Boolean arithmetic）}\par
        \begin{itemize}
            \item 使用 0-1矩阵的算法通常是基于布尔算术
            \item 布尔运算
            \[
            b_1 \land b_2 = 
            \begin{cases}
            1 & \text{如果 } b_1 = b_2 = 1 \\
            0 & \text{否则}
            \end{cases}
            , \quad
            b_1 \lor b_2 = 
            \begin{cases}
            1 & \text{如果 } b_1 = 1 \text{ 或者 } b_2 = 1 \\
            0 & \text{否则}
            \end{cases}
            \]
        \end{itemize}

        \textbf{0-1矩阵的并（join）和交（meet）}\par
        \begin{itemize}
            \item 令 $A = [a_{ij}]$ 和 $B = [b_{ij}]$ 为 $m \times n$ 的 0-1矩阵
            \item 矩阵 $A$ 和 $B$ 的并是一个 $m \times n$ 的 0-1矩阵，其 $i,j$ 项为 $a_{ij} \lor b_{ij}$
            \item 矩阵 $A$ 和 $B$ 的并，记作 $A \lor B$
            \item 矩阵 $A$ 和 $B$ 的交是一个 $m \times n$ 的 0-1矩阵，其 $i,j$ 项为 $a_{ij} \land b_{ij}$
            \item 矩阵 $A$ 和 $B$ 的交，记作 $A \land B$
        \end{itemize}
    
        \textbf{示例：}\par
        \[
        A =
        \begin{bmatrix}
        1 & 0 & 1 \\
        0 & 1 & 0
        \end{bmatrix}
        , \quad
        B =
        \begin{bmatrix}
        0 & 1 & 0 \\
        1 & 1 & 0
        \end{bmatrix}
        \]
        \[
        A \lor B =
        \begin{bmatrix}
        1 \lor 0 & 0 \lor 1 & 1 \lor 0 \\
        0 \lor 1 & 1 \lor 1 & 0 \lor 0
        \end{bmatrix}
        =
        \begin{bmatrix}
        1 & 1 & 1 \\
        1 & 1 & 0
        \end{bmatrix}
        \]
        \[
        A \land B =
        \begin{bmatrix}
        1 \land 0 & 0 \land 1 & 1 \land 0 \\
        0 \land 1 & 1 \land 1 & 0 \land 0
        \end{bmatrix}
        =
        \begin{bmatrix}
        0 & 0 & 0 \\
        0 & 1 & 0
        \end{bmatrix}
        \]
    

        \textbf{0-1矩阵的布尔积（Boolean product）}\par
        \begin{itemize}
            \item 令 $A = [a_{ij}]$ 为 $m \times k$ 的 0-1矩阵，$B = [b_{ij}]$ 为 $k \times n$ 的 0-1矩阵
            \item 矩阵 $A$ 和 $B$ 的布尔积是一个 $m \times n$ 的 0-1矩阵，其 $i,j$ 项为
            \[
            c_{ij} = (a_{i1} \land b_{1j}) \lor (a_{i2} \land b_{2j}) \lor \cdots \lor (a_{ik} \land b_{kj})
            \]
            \item 矩阵 $A$ 和 $B$ 的布尔积记作 $A \bigodot  B$ （符号 $\bigodot $ 有时候被用作表示 Hadamard积）
            \item 矩阵 $A$ 和 $B$ 的布尔积等价于：先做普通矩阵乘积，再转换为 0-1矩阵
        \end{itemize}
    
        \textbf{示例：}\par
        \[
        A =
        \begin{bmatrix}
        1 & 0 \\
        0 & 1 \\
        1 & 0
        \end{bmatrix}
        , \quad
        B =
        \begin{bmatrix}
        1 & 1 & 0 \\
        0 & 1 & 1
        \end{bmatrix}
        \]
        \[
        A \bigodot  B =
        \begin{bmatrix}
        (1 \land 1) \lor (0 \land 0) & (1 \land 1) \lor (0 \land 1) & (1 \land 0) \lor (0 \land 1) \\
        (0 \land 1) \lor (1 \land 0) & (0 \land 1) \lor (1 \land 1) & (0 \land 0) \lor (1 \land 1) \\
        (1 \land 1) \lor (0 \land 0) & (1 \land 1) \lor (0 \land 1) & (1 \land 0) \lor (0 \land 1)
        \end{bmatrix}
        =
        \begin{bmatrix}
        1 \lor 0 & 1 \lor 0 & 0 \lor 0 \\
        0 \lor 0 & 0 \lor 1 & 0 \lor 1 \\
        1 \lor 0 & 1 \lor 0 & 0 \lor 0
        \end{bmatrix}
        =
        \begin{bmatrix}
            1 & 1 & 0 \\
            0 & 1 & 1 \\
            1 & 1 & 0
            \end{bmatrix}
            \]

 \textbf{0-1矩阵的布尔幂（Boolean power）}\par
    \begin{itemize}
        \item 令 $A$ 为一个 $n \times n$ 的 0-1方阵
        \item $A$ 的 $r$ 次布尔幂是 $r$ 个 $A$ 的布尔积，记作 $A^{[r]}$
        \item $A^{[0]} = I_n$
        \item $A^{[r]} = A \circ A^{[r-1]}, \quad r \geq 1$
        \item 布尔幂是良定义的，因为布尔积满足结合律
    \end{itemize}

    \textbf{示例：}\par
    \[
    A =
    \begin{bmatrix}
    0 & 0 & 1 \\
    1 & 0 & 0 \\
    1 & 1 & 0
    \end{bmatrix}
    \]
    \[
    A^{[2]} = A \bigodot  A =
    \begin{bmatrix}
    1 & 1 & 0 \\
    0 & 0 & 1 \\
    1 & 0 & 1
    \end{bmatrix}
    , \quad
    A^{[3]} = A \bigodot  A^{[2]} =
    \begin{bmatrix}
    1 & 0 & 1 \\
    1 & 1 & 0 \\
    1 & 1 & 1
    \end{bmatrix}
    \]
    \[
    A^{[4]} = A \bigodot  A^{[3]} =
    \begin{bmatrix}
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    1 & 1 & 1
    \end{bmatrix}
\]
$A^{[5]} = A \bigodot  A^{[4]} =$
\[
\begin{pmatrix}
1 & 1 & 1 \\
1 & 1 & 1 \\
1 & 1 & 1
\end{pmatrix}
\]
$A^{[r]} = A^{[5]}$，$r \geq 5$
\end{definition}



\chapter{算法基础}\thispagestyle{fancy} 

\section{算法}

\subsection{算法}

\begin{definition}
    \textbf{算法（algorithm）}\par
    \begin{itemize}
        \item 为了进行一项计算或者求解一个问题的精确指令的有限序列
        \item algorithm 一词来源于 9 世纪的一位数学家花拉子密（al-khowarizmi）
        \item 起初 algorism 一词用于表示使用十进制记号作算术运算的规则
        \item 随着计算机的发展，算法的概念被赋予更通用的含义，不仅包含计算的过程，也包含所有用于解题的过程
    \end{itemize}

    \textbf{示例：}\par
    描述一个算法，找到一个有限整数序列中最大值\par
    \textbf{序列最大值算法}\par
    \begin{enumerate}
        \item 设置一个临时最大值，令其等于序列的第一个元素
        \item 将序列中下一个元素与临时最大值进行比较
        \item 如果该元素大于临时最大值，则令临时最大值等于该元素
        \item 重复第 2-3 步，直到序列中的所有元素都完成比较
        \item 算法终止，此时临时最大值就是这个序列中的最大整数
    \end{enumerate}

    \textbf{算法的描述}\par
    \begin{itemize}
        \item 自然语言
        \item 计算机编程语言
    \end{itemize}

    \textbf{伪代码（pseudocode）}\par
    \begin{itemize}
        \item 伪代码是一种介于自然语言和计算机编程语言之间的算法描述
        \item 程序员可以很容易地将伪代码转换为特定编程语言的计算机程序
        \item 伪代码可以用于分析算法的性质，而不依赖于具体的计算机编程语言
        \item 伪代码可以避免自然语言容易产生的歧义
    \end{itemize}

    \textbf{算法的性质}\par
    \begin{itemize}
        \item 输入（input）：算法有一个来自指定集合的输入值
        \item 输出（output）：对每组输入，算法从指定集合中产生输出值，即问题的解
        \item 明确性（definiteness）：算法的每个步骤必须是准确定义的
        \item 正确性（correctness）：对每组输入，算法都应该产生正确的输出值
        \item 有限性（finiteness）：对任意输入，算法都应该在有限（可能很多）步内产生期望的输出
        \item 有效性（effectiveness）：算法的每一步都应该能在有限时间内准确完成
        \item 一般性（generality）：算法应该可以应用于期望形式的所有问题，而不仅仅是某些特定的输入值
    \end{itemize}
\end{definition}

\subsection{搜索算法}

\begin{definition}
    \textbf{搜索问题}\par
    \begin{itemize}
        \item 在一个由不同元素构成的列表 $a_1, a_2, a_3, \ldots, a_n$ 中确定元素 $x$ 的位置，或者判定 $x$ 不在这个列表中
        \item 搜索问题的解，是这个列表中等于 $x$ 的元素的位置 $i$ （如果 $a_i = x$）或者 0 （如果 $x$ 不在这个列表中）
        \item 例如图书馆在允许一个用户借阅书籍前，会搜索这名用户是否在超期未还的名单中
        \item 本章将介绍两个经典的搜索算法：线性搜索、二分搜索
    \end{itemize}

    \textbf{线性搜索（linear search）}\par
    \begin{itemize}
        \item 又称顺序搜索算法（sequential search）
        \item 线性搜索算法从第一个元素开始，逐个比较 $x$ 和列表中的元素，直到找到匹配的元素为止，如果搜索完整个列表还没有找到等于 $x$ 的元素就返回 0
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure linear_search(x: 整数, A: 长度为n的整数序列)
            i = 1
            while (i <= n 和 x \neq A[i])
                i = i + 1
            if i <= n then location = i
            else location = 0
            return location
    \end{verbatim}

    \textbf{二分搜索（binary search）}\par
    \begin{itemize}
        \item 当列表中元素以升序排列时可以使用二分搜索
        \item 例如数值按从小到大、字符串按字典序排列
        \item 通过比较 $x$ 和列表的中间项，可以判定要搜索的元素在列表的哪部分，缩小搜索范围，然后继续在子列表上进行，直至找到匹配的元素
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure binary_search(x: 整数, A: 长度为n的整数序列)
            i = 1; j = n
            while (i < j)
                m = floor((i+j)/2)
                if x > A[m] then i = m+1 else j = m
            if x == A[i] then location = i else location = 0
            return location
    \end{verbatim}
\end{definition}

\subsection{排序算法}

\begin{definition}
    \textbf{排序问题}\par
    \begin{itemize}
        \item 将一个列表中的元素按升序（如数值大小、字符串的字典序等）进行排列
        \item 排序是一个重要问题
        \begin{itemize}
            \item 相当一部分比例的计算资源被用于执行各种排序，特别是在大型数据库中
            \item 排序算法数量惊人，目前已有100多种，而且不断有新的算法出现
            \item 排序算法在展示计算机科学的基本概念和记号时十分有用
        \end{itemize}
        \item 本章将会介绍两个经典的排序算法：冒泡排序、插入排序
        \item 其他经典排序算法：二分排序、选择排序、合并排序、快速排序
    \end{itemize}

    \textbf{冒泡排序（bubble sort）}\par
    \begin{itemize}
        \item 最简单的排序算法之一，但不是最有效的排序算法之一
        \item 比较相邻元素，如果相邻元素不满足顺序要求就交换相邻元素
        \item 通过多轮检查完成整个列表的排序
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure bubble_sort(A: 长度为n的实数序列, n >= 2)
            for i = 1 to n-1
                for j = 1 to n-i
                    if A[j] > A[j+1] then 交换 A[j] 和 A[j+1]
            return A
    \end{verbatim}

    \textbf{插入排序（insertion sort）}\par
    \begin{itemize}
        \item 插入排序是一种简单的排序算法，但通常不是最有效的
        \item 逐个检查第 $j$ 个元素，并把它插入到前 $j-1$ 个元素中的正确位置
        \item 使用线性搜索算法为每个元素寻找正确位置
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure insertion_sort(A: 长度为n的实数序列, n >= 2)
            for j = 2 to n
                i = 1
                while (A[j] > A[i])
                    i = i+1
                m = A[j]
                for k = 0 to j-i-1
                    A[j-k] = A[j-k-1]
                A[i] = m
            return A
    \end{verbatim}
\end{definition}
\subsection{贪婪算法}

\begin{definition}
    \textbf{排序问题}\par
    \begin{itemize}
        \item 将一个列表中的元素按升序（如数值大小、字符串的字典序等）进行排列
        \item 排序是一个重要问题
        \begin{itemize}
            \item 相当一部分比例的计算资源被用于执行各种排序，特别是在大型数据库中
            \item 排序算法数量惊人，目前已有100多种，而且不断有新的算法出现
            \item 排序算法在展示计算机科学的基本概念和记号时十分有用
        \end{itemize}
        \item 本章将会介绍两个经典的排序算法：冒泡排序、插入排序
        \item 其他经典排序算法：二分排序、选择排序、合并排序、快速排序
    \end{itemize}

    \textbf{冒泡排序（bubble sort）}\par
    \begin{itemize}
        \item 最简单的排序算法之一，但不是最有效的排序算法之一
        \item 比较相邻元素，如果相邻元素不满足顺序要求就交换相邻元素
        \item 通过多轮检查完成整个列表的排序
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure bubble_sort(A: 长度为n的实数序列, n >= 2)
            for i = 1 to n-1
                for j = 1 to n-i
                    if A[j] > A[j+1] then 交换 A[j] 和 A[j+1]
            return A
    \end{verbatim}

    \textbf{插入排序（insertion sort）}\par
    \begin{itemize}
        \item 插入排序是一种简单的排序算法，但通常不是最有效的
        \item 逐个检查第 $j$ 个元素，并把它插入到前 $j-1$ 个元素中的正确位置
        \item 使用线性搜索算法为每个元素寻找正确位置
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure insertion_sort(A: 长度为n的实数序列, n >= 2)
            for j = 2 to n
                i = 1
                while (A[j] > A[i])
                    i = i+1
                m = A[j]
                for k = 0 to j-i-1
                    A[j-k] = A[j-k-1]
                A[i] = m
            return A
    \end{verbatim}
\end{definition}

\subsection{贪婪算法}

\begin{definition}
    \textbf{贪婪算法（greedy algorithm）}\par
    \begin{itemize}
        \item 一种简单的优化问题求解算法
        \item 在每一步都选择当前看起来“最好”的选项，而不考虑其他步骤
        \item 每一步最好不一定能保证最终结果最好，但在许多实例上可以找到最优解
        \item 当贪婪算法求得了一个可行解，我们需要知道它是否找到了最优解
        \item 对于一个贪婪算法，我们要证明这个算法一定能找到优化问题的最优解，或者给出一个反例证明这个算法不一定能找到最优解
        \item 设计贪婪算法，需要确定每一步的“最好”选择是什么
        \item 贪婪算法是算法范型（algorithmic paradigm）的一个例子，换句话说，贪婪算法不是一个算法，而是一类算法或者说一种设计算法的通用方法
    \end{itemize}

    \textbf{例6（找零钱问题）}\par
    \begin{itemize}
        \item 考虑用 25分、10分、5分、1分的硬币找零钱
        \item 如何用最少数量的硬币找 $n$ 分零钱？
        \item $n = 67$
        \item 6个硬币：25分×2、10分×1、5分×1、1分×2
        \item $n = 31$
        \item 3个硬币：25分×1、5分×1、1分×1
    \end{itemize}

    \textbf{收银员算法}\par
    \begin{itemize}
        \item 输入： $n$，$C = [25, 10, 5, 1]$
        \item 输出： 每种硬币的数量
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{verbatim}
        procedure cashier_algorithm(n: 整数, 需要找的零钱; C: 长度为m的整数序列, 
        从大到小排序, 表示m种硬币的面值)
            for i = 1 to m
                D[i] = 0
            while (n >= C[i])
                D[i] = D[i]+1
                n = n-C[i]
            return D
    \end{verbatim}

    \textbf{收银员算法的最优性}\par
    \begin{itemize}
        \item 对于美元（4种硬币：25分、10分、5分、1分），收银员算法的输出一定是最优解
    \end{itemize}

    \textbf{引理1}\par
    \begin{itemize}
        \item 如果 $n$ 是一个正整数，那么 $n$ 分零钱使用最少数量的硬币方案中，最多有2个10分硬币、1个5分硬币、4个1分硬币，而且不可能同时有2个10分硬币和1个5分硬币。所有10分、5分、1分硬币的总和不能超过24分。
        \item 用归谬证明法可以证明：如果方案中有超过引理中数量的硬币，总是可以用更大面值的硬币替换，从而减少使用的硬币数量。
    \end{itemize}

    \textbf{定理1}\par
    \begin{itemize}
        \item 对于美元（4种硬币：25分、10分、5分、1分），收银员算法的输出一定是硬币数量最少的解
        \item 证明：使用归谬证明法，
        \begin{itemize}
            \item 令收银员算法输出的结果为 $A$，假设 $A$ 不是最优解，那么存在另一个解 $B$ 使用了最少硬币数量，而且解 $B$ 与解 $A$ 不同。
            \item 令 $k_A$ 为解 $A$ 中使用的25分硬币数量，$k_B$ 为解 $B$ 中使用的25分硬币数量。
            \item 由收银员算法的贪婪性质可知，$k_A \geq k_B$。而由引理可知，解 $B$ 中除了25分硬币其他硬币的总和不能超过24分。因此 $k_A = k_B$。
            \item 类似的，可以证明解 $A$ 的10分、5分、1分硬币数量与解 $B$ 都是相同的。
            \item 这与假设解 $B$ 与解 $A$ 不同矛盾。
        \end{itemize}
    \end{itemize}

    \textbf{收银员算法的最优性依赖于硬币面值}\par
    \begin{itemize}
        \item 对于美元（4种硬币：25分、10分、5分、1分）是成立的
        \item 增加一种硬币 50分，最优性仍然成立
        \item 考虑只有3种类型硬币：25分、10分、1分
        \item 最优性不再成立
        \item 例如：找零31分
        \begin{itemize}
            \item 最优解：4个硬币， 10分×3、1分×1
            \item 算法输出？
            \item 为什么？
        \end{itemize}
    \end{itemize}

    \textbf{例7（最优日程问题）}\par
    \begin{itemize}
        \item 有一组讲座需要安排日程，每个讲座有固定的开始时间和结束时间，如何在一个报告厅安排最多数量讲座，使得满足以下规则
        \begin{itemize}
            \item 一个讲座开始后就不能停止，直到讲座结束
            \item 不能有两个讲座同时进行
            \item 一个讲座结束时可以马上开始另一个讲座
        \end{itemize}
        \item 设计贪婪算法
        \begin{itemize}
            \item 每步选择一个“最好的”讲座加入
            \item 与前面步骤中已经选择的讲座时间冲突的讲座都不能再加入
            \item 如何定义每一步中“最好的”？
        \end{itemize}
    \end{itemize}

    \textbf{最优日程问题可能使用的贪婪准则}\par
    \begin{itemize}
        \item 准则1：和已选讲座不冲突的讲座中，开始时间最早的
        \item 准则2：和已选讲座不冲突的讲座中，讲座时间最短的
        \item 准则3：和已选讲座不冲突的讲座中，结束时间最早的
        \item 准则1和准则2不能保证贪婪算法的最优性
        \item 反例？
    \end{itemize}

    \textbf{贪婪准则1的反例}\par
    \begin{itemize}
        \item 讲座1： 09:00-12:00
        \item 讲座2： 10:00-11:00
        \item 讲座3： 11:00-12:00
    \end{itemize}

    \textbf{贪婪准则2的反例}\par
    \begin{itemize}
        \item 讲座1： 09:00-10:30
        \item 讲座2： 10:00-11:00
        \item 讲座3： 10:30-12:00
    \end{itemize}

    \textbf{基于贪婪准则3的最优日程算法}\par
    \begin{itemize}
        \item 准则3：和已选讲座不冲突的讲座中，结束时间最早的
        \item 利用排序算法对讲座结束时间进行排序
        \item 依次检查每个讲座是否与已选讲座冲突，如不冲突则可以加入
        \item 证明该算法的最优性，需要用到数学归纳法
    \end{itemize}

    \textbf{伪代码：}\par
    \begin{definition}
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.8\textwidth]{al1.png}
        \end{figure}
    \end{definition}
\end{definition}

\subsection{停机问题}

\begin{definition}
    停机问题（halting problem）
    \begin{itemize}
        \item 计算机科学中的一个著名问题
        \item 是否存在一个过程（procedure），以一个计算机程序以及该程序的一个输入作为输入，判断该程序在给定的这个输入上运行时是否最终能停止
        \item 如果存在这样的过程，那么对于编写或者调试程序非常有用
        \item 1936年图灵证明这样的过程是不存在的
        \item 我们不能简单地运行一个程序并观察它是否能停止，因为它的运行时间可能很长（但仍然是有限的一个值）
    \end{itemize}

    \textbf{停机问题证明}
    \begin{itemize}
        \item 使用归谬证明法
        \item 假设存在这样的过程，记为 $H(P, I)$ ，该过程以程序 $P$ 和程序 $P$ 的输入 $I$ 作为输入，判断 $P(I)$ 是否能停止
        \begin{itemize}
            \item 如果 $P(I)$ 最终能停止，那么 $H(P, I)$ 将返回“停止”
            \item 如果 $P(I)$ 不能停止，那么 $H(P, I)$ 将返回“永远循环”
        \end{itemize}
        \item 因为程序本身就是字符串，或者说比特串，因此可以将 $P$ 作为输入
        \item 构造一个过程 $Q(P)$ ，即该过程以程序 $P$ 作为输入，运行方式如下：
        \begin{itemize}
            \item 如果 $H(P, P)$ 输出“停止”，那么让过程 $Q(P)$ 进入无限循环
            \item 如果 $H(P, P)$ 输出“永远循环”，那么让过程 $Q(P)$ 停止
        \end{itemize}
        \item 现在考虑过程 $Q(Q)$ 的运行结果，即将 $Q$ 作为过程 $Q$ 的输入
        \begin{itemize}
            \item 如果 $H(Q, Q)$ 的输出为“停止”，根据 $Q$ 的构造方式，$Q(Q)$ 将进入无限循环
            \item 如果 $H(Q, Q)$ 的输出为“永远循环”，根据 $Q$ 的构造方式，$Q(Q)$ 将停止
        \end{itemize}
        \item 无论哪种情况， $Q(Q)$ 的运行结果都和 $H(Q, Q)$ 的输出不同
        \item 即 $H(Q, Q)$ 不能正确判断 $Q(Q)$ 是否能停止，这与 $H(P, I)$ 的假设矛盾
        \item 因此不存在这样的过程，即停机问题是不可解的
    \end{itemize}
\end{definition}

\section{函数的增长}

\subsection{大O记号}

\begin{definition}
    \textbf{大O记号（Big-O notation）}
    \begin{itemize}
        \item 令 $f$ 和 $g$ 为从整数集或实数集到实数集的函数
        \item 我们说 $f(n)$ 是 $O(g(n))$ 如果存在常数 $C$ 和 $k$ 使得当 $n > k$ 有 $|f(n)| \leq C |g(n)|$
        \item 读作“$f(n)$ 是大O $g(n)$ 的”
        \item 又称 $g$ 渐进支配（asymptotical dominate） $f$，即当 $n$ 无限增长时，$|f(n)|$ 的增长慢于 $|g(n)|$ 的某个常数倍
        \item 大O记号给出了函数 $f$ 增长的上限
        \item 常数 $C$ 和 $k$ 称为 $f(n)$ 是 $O(g(n))$ 的关系的凭证（witness）
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{daO.png}
    \end{figure}

    \textbf{函数的选择}
    \begin{itemize}
        \item 假设 $f$ 是 $O(g(n))$ 的，如果对于足够大的 $n$ 有 $|h(n)| \geq |g(n)|$，则 $f$ 是 $O(h(n))$ 的
        \item 更进一步，大O记号满足传递性，即如果 $f$ 是 $O(g(n))$ 的，$g$ 是 $O(h(n))$ 的，那么 $f$ 是 $O(h(n))$ 的
        \item 通常在研究 $f$ 是 $O(g(n))$ 关系时，函数 $g$ 的选择应该尽可能小
        \item 很多时候函数 $g$ 是从一个参考函数集合中选取，例如形为 $n^k$ 的函数
        \item 因为在使用大O记号，几乎总是涉及只有正值的函数，所以在判断不等式成立时可以忽略绝对值符号
    \end{itemize}

    \textbf{例2：}
    \begin{itemize}
        \item 证明 $7n^2$ 是 $O(n^3)$ 的
        \item 当 $n > 7$ 时，有 $7n^2 < n^3$
        \item 因此取 $C = 1$ 和 $k = 7$ 可以作为凭证以证明 $7n^2$ 是 $O(n^3)$ 的
        \item 当 $n > 1$ 时，有 $7n^2 < 7n^3$
        \item 因此取 $C = 7$ 和 $k = 1$ 也可以作为凭证以证明 $7n^2$ 是 $O(n^3)$ 的
        \item 注意到 $7n^2$ 也是 $O(n^2)$ 的，而 $n^2$ 的增长比 $n^3$ 要慢很多
        \item 因此 $n^2$ 能更好地估计 $7n^2$ 的增长，事实上 $n^2$ 是最适合估计 $7n^2$ 的 $n^k$ 函数中最小可能幂次
    \end{itemize}

    \textbf{例3：}
    \begin{itemize}
        \item 证明 $n^2$ 不是 $O(n)$ 的
        \item 使用归谬证明法
        \item 假设存在常数 $C$ 和 $k$ 使得当 $n > k$ 时有 $|n^2| \leq C|n|$
        \item 当 $n > 0$ 时，在不等式 $|n^2| \leq C|n|$ 两边同时除以 $|n|$ 可得 $|n| \leq C$
        \item 无论 $C$ 和 $k$ 如何取值，不等式 $|n| \leq C$ 不可能对所有的 $n > k$ 都成立
        \item 因此 $n^2$ 不是 $O(n)$ 的
    \end{itemize}
\end{definition}

\subsubsection{一些重要函数的大O估计}

\begin{definition}
    \textbf{多项式函数}
    \begin{itemize}
        \item 考虑 $f(n) = a_k n^k + a_{k-1} n^{k-1} + \cdots + a_1 n + a_0$，其中 $a_i$ 为实数，$a_k \neq 0$
        \item 证明 $f(n)$ 是 $O(n^k)$ 的：假设 $n > 1$
        \[
        f(n) = a_k n^k + a_{k-1} n^{k-1} + \cdots + a_1 n + a_0
        \leq a_k n^k + a_{k-1} n^{k-1} + \cdots + a_1 n + a_0
        = a_k n^k + a_{k-1} \frac{n^{k-1}}{n} + \cdots + a_1 \frac{n}{n^{k-1}} + \frac{a_0}{n^k}
        \leq a_k n^k + a_{k-1} + \cdots + a_1 + a_0
        \]
        \item 令 $C = a_k + a_{k-1} + \cdots + a_1 + a_0$ 和 $k = 1$
        \item 可证 $f(n)$ 是 $O(n^k)$ 的
    \end{itemize}

    \textbf{整数和：}
    \begin{itemize}
        \item 使用大O估计前 $n$ 个整数的和
        \[
        1 + 2 + \cdots + n \leq n + n + \cdots + n = n^2
        \]
        \item 令 $C = 1$ 和 $k = 1$ 可证 $1 + 2 + \cdots + n$ 是 $O(n^2)$ 的
    \end{itemize}

    \textbf{阶乘函数：}
    \begin{itemize}
        \item 使用大O估计阶乘函数 $n! = 1 \times 2 \times 3 \times \cdots \times n$
        \[
        n! = 1 \times 2 \times 3 \times \cdots \times n \leq n \times n \times n \times \cdots \times n = n^n
        \]
        \item 令 $C = 1$ 和 $k = 1$ 可证 $n!$ 是 $O(n^n)$ 的
    \end{itemize}

    \textbf{对数阶乘函数：}
    \begin{itemize}
        \item 使用大O估计对数阶乘函数 $\log n!$
        \[
        n! \leq n^n
        \]
        \item 两边取对数可得
        \[
        \log n! \leq n \log n
        \]
        \item 令 $C = 1$ 和 $k = 1$ 可证 $\log n!$ 是 $O(n \log n)$ 的
    \end{itemize}

    \textbf{同类型函数比较}
    \begin{itemize}
        \item 如果 $a > b > 1$，则 $a^n$ 是 $O(b^n)$ 的，但 $b^n$ 不是 $O(a^n)$ 的
        \item 如果 $a > b > 1$，则 $n^a$ 是 $O(n^b)$ 的，但 $n^b$ 不是 $O(n^a)$ 的
    \end{itemize}

    \textbf{不同类型函数比较}
    \begin{itemize}
        \item 如果 $a > 1, b, c > 0$，则 $\log^c n$ 是 $O(n^b)$ 的，但 $n^b$ 不是 $O(\log^c n)$ 的
        \item 如果 $a > 1, b > 0$，则 $n^b$ 是 $O(a^n)$ 的，但 $a^n$ 不是 $O(n^b)$ 的
        \item 如果 $a > 1$，则 $n^a$ 是 $O(n!)$ 的，但 $n!$ 不是 $O(n^a)$ 的
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{daOgo.png}
    \end{figure}
\end{definition}

\subsubsection{函数组合的大O估计}

\begin{definition}
    \textbf{定理：}
    \begin{itemize}
        \item 如果 $f_1(n)$ 是 $O(g_1(n))$ 的，$f_2(n)$ 是 $O(g_2(n))$ 的，则
        \[
        f_1 + f_2 \text{ 是 } O(\max(g_1(n), g_2(n)))
        \]
        \[
        f_1 f_2 \text{ 是 } O(g_1(n) g_2(n))
        \]
    \end{itemize}

    \textbf{推论：}
    \begin{itemize}
        \item 如果 $f_1(n)$ 是 $O(g(n))$ 的，$f_2(n)$ 是 $O(g(n))$ 的，则
        \[
        f_1 + f_2 \text{ 是 } O(g(n))
        \]
    \end{itemize}

    \textbf{证明：}
\begin{itemize}
    \item 如果 $f_1(n)$ 是 $O(g_1(n))$ 的，$f_2(n)$ 是 $O(g_2(n))$ 的，则存在 $C_1, k_1, C_2, k_2$ 使得当 $n > k_1$ 时有 $|f_1(n)| \leq C_1 |g_1(n)|$，当 $n > k_2$ 时有 $|f_2(n)| \leq C_2 |g_2(n)|$
    \[
    |f_1 + f_2| \leq |f_1(n)| + |f_2(n)| \leq C_1 |g_1(n)| + C_2 |g_2(n)| \leq (C_1 + C_2) \max(|g_1(n)|, |g_2(n)|)
    \]
    \item 令 $C = C_1 + C_2$ 和 $k = \max(k_1, k_2)$，可证 $f_1 + f_2$ 是 $O(\max(g_1(n), g_2(n)))$ 的
    \[
    |f_1 f_2| = |f_1(n) f_2(n)| \leq C_1 |g_1(n)| C_2 |g_2(n)| = C_1 C_2 |g_1(n) g_2(n)|
    \]
    \item 令 $C = C_1 C_2$ 和 $k = \max(k_1, k_2)$，可证 $f_1 f_2$ 是 $O(g_1(n) g_2(n))$ 的
\end{itemize}

\textbf{例9：}
\begin{itemize}
    \item 给出 $f(n) = 3n \log n! + (n^2 + 3) \log n$ 的大O估计
    \item 因为 $\log n!$ 是 $O(n \log n)$ 的，所以 $3n \log n!$ 是 $O(n^2 \log n)$，又因为 $n^2 + 3$ 是 $O(n^2)$ 的，所以 $(n^2 + 3) \log n$ 是 $O(n^2 \log n)$
    \item 所以 $f(n)$ 是 $O(n^2 \log n)$ 的
\end{itemize}

\textbf{例10：}
\begin{itemize}
    \item 给出 $f(n) = (n+1) \log(n^2 +1) 3n^2$ 的大O估计
    \item 因为 $\log(n^2+1)$ 是 $O(\log n)$ 的，所以 $(n +1) \log(n^2+1)$ 是 $O(n \log n)$ 的
    \item 又因为 $3n^2$ 是 $O(n^2)$ 的，所以 $f(n)$ 是 $O(n^2)$ 的
\end{itemize}
\end{definition}


\subsection{大Ω记号与大Θ记号}

\begin{definition}
    \textbf{大Ω记号（Big-Ω notation）}
    \begin{itemize}
        \item 令 $f$ 和 $g$ 为从整数集或实数集到实数集的函数
        \item 我们说 $f(n)$ 是 $\Omega(g(n))$ 如果存在常数 $C$ 和 $k$ 使得当 $n > k$ 时有 $|f(n)| \geq C |g(n)|$
        \item 读作“$f(n)$ 是大Ω $g(n)$ 的”
        \item 即当 $n$ 无限增长时，$f(n)$ 的增长快于 $g(n)$ 的某个常数倍
        \item 大O记号给出了函数增长的上限，而大Ω记号给出了增长的下限
        \item $f(n)$ 是 $\Omega(g(n))$ 的当且仅当 $g(n)$ 是 $O(f(n))$ 的
    \end{itemize}

    \textbf{例11：}
    \begin{itemize}
        \item 证明 $8n^3 + 5n^2 + 7$ 是 $\Omega(n^3)$ 的
        \item 对于任意 $n > 0$ 都有 $8n^3 + 5n^2 + 7 \geq n^3$
        \item 令 $C = 1$ 和 $k = 0$ 可证 $8n^3 + 5n^2 + 7$ 是 $\Omega(n^3)$ 的
        \item 以上证明过程与证明 $n^3$ 是 $O(8n^3 + 5n^2 + 7)$ 的是一样的，只需把不等式颠倒过来写
    \end{itemize}

    \textbf{大Θ记号（Big-Θ notation）}
    \begin{itemize}
        \item 令 $f$ 和 $g$ 为从整数集或实数集到实数集的函数
        \item 我们说 $f(n)$ 是 $\Theta(g(n))$ 的当且仅当 $f(n)$ 是 $O(g(n))$ 且 $f(n)$ 是 $\Omega(g(n))$
        \item 读作“$f(n)$ 是大Θ $g(n)$ 的”
        \item 即当 $n$ 无限增长时，$f(n)$ 的增长和 $g(n)$ 一样快（只差一个常数倍）
        \item 称 $f(n)$ 和 $g(n)$ 是同阶的（same order），也称 $f(n)$ 是 $g(n)$ 阶的
        \item $f(n)$ 是 $\Theta(g(n))$ 当且仅当存在常数 $C_1, C_2$ 和 $k$ 使得当 $n > k$ 时有 $C_1 |g(n)| \leq |f(n)| \leq C_2 |g(n)|$
    \end{itemize}

    \textbf{例12：}
    \begin{itemize}
        \item 证明前 $n$ 个整数和是 $\Theta(n^2)$ 的
        \item 我们已经证明 $S(n) = 1 + 2 + \cdots + n$ 是 $O(n^2)$ 的，只需再证明 $S(n)$ 是 $\Omega(n^2)$ 的
        \item 只对大于 $n^2$ 的项进行求和可得
        \[
        S(n) \geq n^2 + \left(n^2 + 1\right) + \cdots + n \geq n^2 \left(n^2 + 1\right) = \frac{n^2}{4} + n^2
        \]
        \item 令 $C = \frac{1}{4}$ 和 $k > 0$ 可证 $S(n)$ 是 $\Omega(n^2)$ 的
        \item 所以 $S(n)$ 是 $\Theta(n^2)$ 的
    \end{itemize}

    \textbf{等价性}
    \begin{itemize}
        \item 如果 $f(n)$ 是 $\Theta(g(n))$ 的，则 $g(n)$ 是 $\Theta(f(n))$ 的
        \item $f(n)$ 是 $\Theta(g(n))$ 的当且仅当 $f(n)$ 是 $O(g(n))$ 且 $f(n)$ 是 $\Omega(g(n))$
    \end{itemize}

    \textbf{大Ω记号和大Θ记号的历史}
    \begin{itemize}
        \item 一个常见的错误是把大O记号当作大Θ记号来使用
        \item 大Ω记号和大Θ记号都是高德纳在1970年引入的
        \item 目的正是为了纠正人们对大O记号的误用
    \end{itemize}

    \textbf{多项式函数的阶数}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{dxs1.png}
    \end{figure}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{dxs2.png}
    \end{figure}
\end{definition}

\section{算法的复杂度}

\subsection{时间复杂度}

\begin{definition}
    \textbf{时间复杂度}
    \begin{itemize}
        \item 以算法所需的运算次数来衡量，而不是算法实际运行的时间（影响因素太多，分析极其复杂）
        \item 忽略算法的实现细节（包括数据结构、硬件和软件平台等）
        \item 使用大O记号和大Θ记号来估计
    \end{itemize}

    \textbf{时间复杂度分析的目的}
    \begin{itemize}
        \item 判断一个算法是否可以实际用于求解特定规模输入的问题
        \item 比较解决同一个问题的不同算法的效率
        \item 估计一个算法在不同平台的运行时间
    \end{itemize}

    \textbf{最坏情形复杂度（worst-case time complexity）}
    \begin{itemize}
        \item 算法用于一定输入规模的问题时所需要的最多运算次数
        \item 对于任意这个规模的输入，算法所需运算次数的上限
        \item 一个算法需要多少次运算就能保证给出问题的解
    \end{itemize}

    \textbf{平均情形复杂度（average-case time complexity）}
    \begin{itemize}
        \item 算法用于一定输入规模的问题时所需要的平均运算次数
        \item 对于所有这个规模的输入，算法所需运算次数的平均值
        \item 平均情形复杂度分析一般比最坏情形复杂度分析困难得多
    \end{itemize}
\begin{definition}
    \textbf{示例1：}
    \begin{itemize}
        \item 分析有限序列最大值算法的最坏时间复杂度
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{sj1.png}
    \end{figure}

    \begin{itemize}
        \item 算法的主要运算是比较，考虑比较运算的次数
        \item 循环的每一轮都要比较 $i < n$ 和 $A[i] > \text{max}$，一共比较了 $2n - 1$ 次
        \item 循环的最后一轮还需要比较 1 次 $i < n$
        \item 因此算法的时间复杂度为 $\Theta(n)$
    \end{itemize}
\end{definition}

\begin{definition}
    \textbf{示例2：}
    \begin{itemize}
        \item 分析线性搜索算法的最坏情形时间复杂度
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{sj2.png}
    \end{figure}

    \begin{itemize}
        \item 循环的每一轮需要 2 次比较，最坏情形需要 $n$ 轮循环
        \item 因此算法的最坏情形时间复杂度为 $\Theta(n)$
    \end{itemize}
\end{definition}

\begin{definition}
    \textbf{示例3：}
    \begin{itemize}
        \item 分析线性搜索算法的平均情形时间复杂度
        \item 假设元素在列表中的位置是一个均匀分布，即在每个位置出现的概率相同
        \item 如果 $x = a_i$，算法所需的比较次数为 $2i + 1$
        \item 所以算法所需的平均比较次数为
        \[
        \frac{3 + 5 + 7 + \cdots + 2n + 1}{n} = \frac{2(1 + 2 + 3 + \cdots + n) + n}{n} = \frac{2 \cdot \frac{n(n + 1)}{2} + n}{n} = n + 2
        \]
        \item 因此算法的平均情形时间复杂度为 $\Theta(n)$
    \end{itemize}
\end{definition}

\begin{definition}
    \textbf{示例4：}
    \begin{itemize}
        \item 分析二分搜索算法的最坏情形时间复杂度
        \item 为简化分析，假定列表中有 $n = 2^k$ 个元素
        \item 那么 $k = \log n$
        \item 循环的每一轮需要 2 次比较
        \item 第 1 轮结束后，列表剩余的区间长度为 $2^{k-1}$
        \item 第 2 轮结束后，列表剩余的区间长度为 $2^{k-2}$
        \item 第 $k$ 轮结束后，列表剩余的区间长度为 $2^{k-k} = 1$，循环终止
        \item 加上循环结束条件的比较和结束后的比较，一共进行了 $2k + 2$ 次比较
        \item 因此算法的最坏情形时间复杂度为 $\Theta(\log n)$，优于线性搜索算法
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{sj3.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{示例5：}
    \begin{itemize}
        \item 分析冒泡排序算法的最坏情形时间复杂度
        \item 外层循环一共要进行 $n - 1$ 轮
        \item 第 $i$ 轮中，内层循环需要 $n - i$ 轮
        \item 每轮内层循环需要 2 次比较
        \item 所以总的比较次数为
        \[
        2 \sum_{i=1}^{n-1} (n - i) = 2 \left( \frac{n(n-1)}{2} \right) = n(n-1) = n^2 - n
        \]
        \item 因此算法的最坏情形时间复杂度为 $\Theta(n^2)$
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{sj4.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{示例6：}
    \begin{itemize}
        \item 分析插入排序算法的最坏情形时间复杂度
        \item 只考虑比较次数
        \item 外层循环需要 $n - 1$ 轮
        \item 内层 while 循环最坏情形需要 $j$ 次比较
        \item 总的比较次数为
        \[
        \sum_{j=2}^{n} j = \frac{n(n+1)}{2} - 1
        \]
        \item 因此算法的最坏情形时间复杂度为 $\Theta(n^2)$
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{sj5.png}
    \end{figure}
\end{definition}
\end{definition}

\subsubsection{矩阵乘法的时间复杂度}

\begin{definition}
    \textbf{$n \times n$ 方阵的矩阵乘法时间复杂度}
    \begin{itemize}
        \item 只考虑加法和乘法运算的次数
        \item 结果矩阵中有 $n^2$ 个元素
        \item 计算每个元素需要 $n$ 次乘法和 $n - 1$ 次加法
        \item 所以一共需要 $n^3$ 次乘法和 $n^2(n - 1)$ 次加法
        \item 因此 $n × n$ 方阵的矩阵乘法时间复杂度为 $\Theta(n^3)$
    \end{itemize}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{sb1.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{$n \times n$ 0-1矩阵的布尔积时间复杂度}
    \begin{itemize}
        \item 只考虑位运算的次数
        \item 结果矩阵中有 $n^2$ 个元素
        \item 计算每个元素需要 $n$ 次与运算和 $n - 1$ 次或运算
        \item 所以一共需要 $n^3$ 次与运算和 $n^2(n - 1)$ 次或运算
        \item 因此 $n × n$ 0-1矩阵的布尔积时间复杂度为 $\Theta(n^3)$
    \end{itemize}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{sb2.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{矩阵链乘法}
    \begin{itemize}
        \item 假设有 $n$ 个矩阵 $A_1, A_2, \cdots, A_n$ 分别为 $m_1 × m_2, m_2 × m_3, \cdots, m_n × m_{n+1}$ 矩阵
        \item 这个矩阵链的乘积 $A_1 A_2 \cdots A_n$ 应该如何计算使用的乘法次数最少？
        \item 给定一个矩阵链
        \item 找到最优的乘法执行顺序
        \item 需要用到动态规划
    \end{itemize}

    例如： $A_1, A_2, A_3$ 分别为 $30 × 20, 20 × 40, 40 × 10$ 矩阵
    \begin{itemize}
        \item 方案1：$A_1 (A_2 A_3)$
        \begin{itemize}
            \item $A_2 A_3$ 需要的乘法次数为 $20 × 40 × 10 = 8000$，然后再乘上 $A_1$ 需要的次数为 $30 × 20 × 10 = 6000$，一共需要 $14000$ 次乘法
        \end{itemize}
        \item 方案2：$(A_1 A_2) A_3$
        \begin{itemize}
            \item $A_1 A_2$ 需要的乘法次数为 $30 × 20 × 40 = 24000$，然后再乘上 $A_3$ 需要的次数为 $30 × 40 × 10 = 12000$，一共需要 $36000$ 次乘法
        \end{itemize}
        \item 方案1需要的乘法次数最少
    \end{itemize}
\end{definition}

\subsection{算法范型}

\begin{definition}
    \textbf{算法范型（algorithmic paradigm）}
    \begin{itemize}
        \item 一个算法范型是一种基于一个特定概念的通用方法，用于构造求解一类广泛问题的算法
        \item 贪心算法（greedy algorithms）是一个算法范型
        \item 蛮力算法（brute-force algorithms）是另一个基本的但又重要的算法范型
        \item 分治算法（divide-and-conquer algorithms）
        \item 动态规划（dynamic programming）算法
        \item 回溯（backtracking）算法
        \item 随机算法（probabilistic algorithms）
        \item ……
    \end{itemize}

    \textbf{蛮力算法}
    \begin{itemize}
        \item 又称暴力算法
        \item 通过基于对问题的描述和定义以最直接的方式解决问题
        \item 没有利用问题的任何特殊结构或者聪明的主意
        \item 前面介绍的算法中有一些属于蛮力算法
        \begin{itemize}
            \item 有限序列的最大值算法
            \item 线性搜索算法
            \item 冒泡排序算法
            \item 插入排序算法
            \item 基于定义的矩阵乘法
        \end{itemize}
    \end{itemize}

    \textbf{示例：}
    \begin{itemize}
        \item 构造一个蛮力算法，寻找平面上 $n$ 个点的集合中的最近点对（closest pair of points），并给出最坏情形时间复杂度
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{ag1.png}
    \end{figure}

    \begin{itemize}
        \item 外层循环需要 $n - 1$ 轮
        \item 第 $i$ 轮外层循环中，内层循环需要 $n - i$ 轮
        \item 一共执行了 $n - 1 + n - 2 + \cdots + 1 = \frac{n(n-1)}{2}$ 轮循环
        \item 每轮内层循环计算 $1$ 次 $(x_i - x_j)^2 + (y_i - y_j)^2$ 并将结果与最小值进行比较
        \item 因此以算术运算和比较运算计算，算法的时间复杂度为 $\Theta(n^2)$
        \item 使用分治算法可以达到 $\Theta(n \log n)$ 的时间复杂度
    \end{itemize}
\end{definition}

\begin{definition}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{fuza1.png}
    \end{figure}
    \textbf{问题复杂性（complexity of problem）}
    \begin{itemize}
        \item 根据一类问题是否存在某种时间复杂度的算法可以研究问题的复杂性
    \end{itemize}

    \textbf{易解问题（tractable problem）}
    \begin{itemize}
        \item 存在多项式最坏情形复杂度算法的问题
        \item 如果多项式的次数或系数太大，算法也不能保证在合理时间内得到解
    \end{itemize}

    \textbf{难解问题（intractable problem）}
    \begin{itemize}
        \item 不存在多项式最坏情形复杂度算法的问题
    \end{itemize}

    \textbf{不可解问题（unsolvable problem）}
    \begin{itemize}
        \item 不存在算法的问题，如停机问题
    \end{itemize}

    \textbf{P类（polynomial class）}
    \begin{itemize}
        \item 可以在多项式时间内求解的问题
    \end{itemize}

    \textbf{NP类（non-deterministic polynomial class）}
    \begin{itemize}
        \item 可以在多项式时间内验证解的问题
        \item 常见误解：NP是non-polynomial的缩写
        \item non-deterministic polynomial是指非确定性图灵机可以在多项式时间内完成
        \item 可满足性问题是一个NP问题的例子：给定一组变量的赋值，可以快速验证命题是否为真，但是穷举搜索所有可能的赋值需要 $\Omega(2^n)$ 次位运算
        \item $NP \setminus P$：目前没有发现多项式时间算法可以求解该类中的问题
    \end{itemize}

    \textbf{NP完全类（NP complete class）}
    \begin{itemize}
        \item NP类的一个重要子类
        \item NP类中的每个问题可以在多项式时间内规约为NP完全问题：
        \begin{itemize}
            \item 任给NP问题A的一个实例A1，可以构造出NP完全问题B的一个实例B1，使得B1的解可以在多项式时间内转换为A1的解
        \end{itemize}
        \item 如果发现可以求解NP完全类中某个问题的多项式时间算法，那么任意NP问题都可以基于这个算法设计出多项式时间算法
        \item 可满足性问题是第一个被证明的NP完全问题（Cook-Levin定理）
    \end{itemize}

    \textbf{P vs NP}
    \begin{itemize}
        \item P vs NP 问题：是否 P = NP？
        \item 现在没找到多项式时间算法不等于不存在多项式时间算法
        \item 通常相信 P ≠ NP
        \item P vs NP 问题是数学中最著名的未解问题之一
        \item Clay数学研究所千禧年七大问题（奖金100万美元）
    \end{itemize}
\end{definition}




\chapter{数论基础}\thispagestyle{fancy}

\section{整除性和模算术}

\subsection{整除}

\begin{definition}
    \textbf{整除}
    \begin{itemize}
        \item 如果 $a, b \in \mathbb{Z}$ 且 $a \neq 0$，如果有 $c \in \mathbb{Z}$ 使得 $b = ac$ 则称 $a$ 整除（divide） $b$
        \item 当 $a$ 整除 $b$ 时我们称 $a$ 是 $b$ 的一个因子（factor）或除数（divisor），而 $b$ 是 $a$ 的一个倍数（multiple）
        \item 用符号 $a \mid b$ 表示 $a$ 整除 $b$，符号 $a \nmid b$ 表示 $a$ 不能整除 $b$
        \item 如果 $a \mid b$，则 $\frac{b}{a}$ 是一个整数
    \end{itemize}

    \textbf{例2：}
    \begin{itemize}
        \item 令 $n, d \in \mathbb{Z}^+$，不超过 $n$ 的正整数中有多少个能被 $d$ 整除
        \item 解答：
        \begin{itemize}
            \item 不超过 $n$ 的正整数中能被 $d$ 整除的数是 $d, 2d, 3d, \ldots, kd$，其中 $kd \leq n$。
            \item 令 $k$ 为满足 $kd \leq n$ 的最大整数。
            \item 因此，$k = \left\lfloor \frac{n}{d} \right\rfloor$。
            \item 所以，不超过 $n$ 的正整数中有 $\left\lfloor \frac{n}{d} \right\rfloor$ 个数能被 $d$ 整除。
        \end{itemize}
    \end{itemize}

    \textbf{整除性（Divisibility）的基本性质}
    \begin{itemize}
        \item 令 $a, b, c \in \mathbb{Z}$，其中 $a \neq 0$，则
        \begin{itemize}
            \item 如果 $a \mid b$ 且 $a \mid c$，则 $a \mid (b + c)$；
            \item 如果 $a \mid b$，那么对 $\forall c \in \mathbb{Z}$ 都有 $a \mid (bc)$；
            \item 如果 $a \mid b$ 且 $b \mid c$，则 $a \mid c$。
        \end{itemize}
    \end{itemize}

    \textbf{推论：}
    \begin{itemize}
        \item 如果 $a, b, c \in \mathbb{Z}$，其中 $a \neq 0$，使得 $a \mid b$ 且 $a \mid c$，那么对 $\forall m, n \in \mathbb{Z}$ 有 $a \mid (mb + nc)$
    \end{itemize}
\end{definition}

\subsection{整除算法}

\begin{definition}
    \textbf{除法算法（Division Algorithm）}
    \begin{itemize}
        \item 如果 $a \in \mathbb{Z}$，$d \in \mathbb{Z}^+$，则存在唯一的 $q, r \in \mathbb{Z}$，其中 $0 \leq r < d$，使得 $a = dq + r$。
        \begin{itemize}
            \item $d$ 称为除数（divisor）
            \item $a$ 称为被除数（dividend）
            \item $q$ 称为商（quotient）
            \item $r$ 称为余数（remainder）
        \end{itemize}
        \item 这不是一个真正的算法（why?），实际上是一个定理。
    \end{itemize}

    \textbf{证明：}
    \begin{itemize}
        \item 存在性：令 $S = \{m \in \mathbb{N} \mid m = a - dk, k \in \mathbb{Z}\}$，则 $S$ 非空，那么 $S$ 存在最小元素（良序性公理，5.2节），设 $S$ 的最小元素为 $m_0 = a - dk_0$。易证 $0 \leq m_0 < d$，令 $q = k_0, r = m_0$。
        \item 唯一性：假设 $a = dq + r = dq' + r'$，则 $d(q - q') = r - r'$，因为 $-d < r - r' < d$，所以 $q - q' = r - r' = 0$。
    \end{itemize}

    \textbf{整除运算符 div 和 mod}
    \begin{itemize}
        \item 用记号 div 表示商： $q = a \div d$
        \item 用记号 mod 表示余数： $r = a \mod d$
        \item 对于固定的 $d$ 而言，div 和 mod 都是整数集合上的函数
        \item 当 $a \in \mathbb{Z}$ 而 $d \in \mathbb{Z}^+$ 时，
        \begin{itemize}
            \item $a \div d = \left\lfloor \frac{a}{d} \right\rfloor$
            \item $a \mod d = a - d \left\lfloor \frac{a}{d} \right\rfloor$
        \end{itemize}
    \end{itemize}
\end{definition}

\subsection{模算术}

\begin{definition}
    \textbf{模算术（Modular Arithmetic）}
    \begin{itemize}
        \item 某些场合我们只关心两个整数相除所得的余数
    \end{itemize}

    \textbf{同余式（Congruence）}
    \begin{itemize}
        \item 如果 $a, b \in \mathbb{Z}$ 而 $m \in \mathbb{Z}^+$，当 $m$ 整除 $a - b$ 时，称 $a$ 与 $b$ 模 $m$ 同余（$a$ congruent to $b$ modulo $m$）
        \item 记为 $a \equiv b \pmod{m}$，称为同余式（congruence），$m$ 为它的模（modulus）
        \item 如果 $a$ 与 $b$ 不是模 $m$ 同余，则记为 $a \not\equiv b \pmod{m}$
    \end{itemize}

    \textbf{同余关系（Congruence Relation）}
    \begin{itemize}
        \item 整数集合上的二元关系，同余关系以及符号 $\equiv$ 由高斯于1801年引入
        \item 两个整数是模 $m$ 同余，当且仅当它们除以 $m$ 所得的余数相同
        \[
        \exists m \in \mathbb{Z}^+, \quad m \mid (a - b) \iff 
        \begin{cases} 
            a = mq_1 + r_1 & 0 \leq r_1 < m \\
            b = mq_2 + r_2 & 0 \leq r_2 < m \\
            r_1 = r_2 
        \end{cases}
        \]
        \item 所有和 $a$ 模 $m$ 同余的整数构成的集合，称为 $a$ 模 $m$ 的同余类（等价类）
    \end{itemize}

    \textbf{同余关系的基本性质}
    \begin{itemize}
        \item 自反性：$a \equiv a \pmod{m}$
        \item 对称性：$a \equiv b \pmod{m} \iff b \equiv a \pmod{m}$
        \item 传递性：$a \equiv b \pmod{m}$ 且 $b \equiv c \pmod{m} \implies a \equiv c \pmod{m}$
    \end{itemize}

    \textbf{记号 (mod $m$) 和 mod $m$ 的联系}
    \begin{itemize}
        \item $a \equiv b \pmod{m}$ 表示整数集合上的一个关系，其中 mod 是关系的参数
        \item $a \mod m = b$ 表示一个运算，mod $m$ 是定义在整数上的函数
    \end{itemize}

    \textbf{定理：}
    \begin{itemize}
        \item 令 $a, b \in \mathbb{Z}$，$m \in \mathbb{Z}^+$，则 $a \equiv b \pmod{m}$ 当且仅当 $a \mod m = b \mod m$
    \end{itemize}

    \textbf{定理（同余的性质）：}
    \begin{itemize}
        \item 令 $m \in \mathbb{Z}^+$，对任意 $a, b \in \mathbb{Z}$，$a \equiv b \pmod{m} \iff \exists k \in \mathbb{Z}, \quad a = b + km$
    \end{itemize}

    \textbf{定理（和与积的同余）：}
    \begin{itemize}
        \item 令 $m \in \mathbb{Z}^+$，如果 $a \equiv b \pmod{m}$，$c \equiv d \pmod{m}$，那么
        \[
        a + c \equiv b + d \pmod{m} \quad \text{和} \quad ac \equiv bd \pmod{m}
        \]
    \end{itemize}

    \textbf{同余式的算术运算：}
    \begin{itemize}
        \item 同余式两端都乘上一个整数，同余式保持成立
        \item 同余式两端都加上一个整数，同余式保持成立
        \item 同余式两端都除以一个整数，同余式不总是保持成立
    \end{itemize}

    \textbf{例：}
    \begin{itemize}
        \item $14 \equiv 8 \pmod{6}$
        \item 乘2：$28 \equiv 16 \pmod{6}$
        \item 加2：$16 \equiv 10 \pmod{6}$
        \item 除2：$7 \not\equiv 4 \pmod{6}$
    \end{itemize}

    \textbf{推论（计算和与积的 mod $m$ 函数）：}
    \begin{itemize}
        \item 令 $m \in \mathbb{Z}^+$，$a, b \in \mathbb{Z}$，那么
        \[
        (a + b) \mod m = ((a \mod m) + (b \mod m)) \mod m
        \]
        \[
        (ab) \mod m = ((a \mod m) (b \mod m)) \mod m
        \]
    \end{itemize}
\end{definition}

\subsection{模m算术}

\begin{definition}
    \textbf{模m算术（Arithmetic Modulo m）}
    \begin{itemize}
        \item 令 $Z_m = \{0, 1, \cdots, m - 1\}$ 表示不超过 $m$ 的非负整数，定义 $Z_m$ 上的算术运算
        \begin{itemize}
            \item 定义 $a +_m b = (a + b) \mod m$，称为模$m$加法（addition modulo $m$）
            \item 定义 $a \cdot_m b = (a \cdot b) \mod m$，称为模$m$乘法（multiplication modulo $m$）
        \end{itemize}
        \item 模$m$加法和模$m$乘法满足普通加法和乘法的许多性质
        \begin{itemize}
            \item 封闭性、结合律、交换律、分配律
            \item 单位元：0（模$m$加法）、1（模$m$乘法）
            \item 加法逆元：0 是其自身的加法逆元，$a \neq 0$ 的加法逆元为 $m - a$
        \end{itemize}
    \end{itemize}
\end{definition}

\section{整数表示和算法}

\subsection{整数的表示}

\begin{definition}
    \textbf{整数的表示}
    \begin{itemize}
        \item 整数可以用任意大于 1 的整数 $b$ 为基数来表示
        \item 在日常生活中使用的整数表示：
        \begin{itemize}
            \item 十进制（decimal） $b = 10$
        \end{itemize}
        \item 在计算机中通常用的整数表示：
        \begin{itemize}
            \item 二进制（binary） $b = 2$
            \item 八进制（octal） $b = 8$
            \item 十六进制（hexadecimal） $b = 16$
        \end{itemize}
    \end{itemize}

    \textbf{进制}
    \begin{itemize}
        \item 进位记数制，每个位置上的数字表示不同的值
    \end{itemize}

    \textbf{位权}
    \begin{itemize}
        \item 进位制中每个位置上的数字对应的单位值（下表中为从右向左第 $n$ 位的位权）
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{zs1.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{定理：}
    \begin{itemize}
        \item 令 $b$ 是一个大于 1 的整数。如果 $n$ 是一个正整数，则可以唯一地表示为下面的形式：
        \[
        n = a_k b^k + a_{k-1} b^{k-1} + \cdots + a_1 b + a_0
        \]
        \item 其中 $k$ 是非负整数，$a_0, a_1, \cdots, a_k$ 是小于 $b$ 的非负整数，且 $a_k \neq 0$。
    \end{itemize}

    \item 这种表示称为 $n$ 的 $b$ 进制展开式（base $b$ expansion of $n$）
    \begin{itemize}
        \item 记为 $a_k a_{k-1} \cdots a_1 a_0 \, b$
        \item 当 $b = 10$ 时下标 $b$ 可以省略
    \end{itemize}

    \textbf{进制转换（Base Conversion）}
    \begin{itemize}
        \item 构造一个整数 $n$ 的 $b$ 进制展开式
        \begin{itemize}
            \item 将 $n$ 除以 $b$ 得到商和余数，即 $n = bq_0 + a_0$，其中 $0 \leq a_0 < b$
            \item 余数 $a_0$ 就是 $n$ 的 $b$ 进制展开式中最右边的数字
            \item 下一步将 $q_0$ 除以 $b$ 得到商和余数，即 $q_0 = bq_1 + a_1$，其中 $0 \leq a_1 < b$
            \item 余数 $a_1$ 就是 $n$ 的 $b$ 进制展开式中右边第二位数字
            \item 继续这一过程，从右向左产生 $n$ 的 $b$ 进制数字
            \item 直至商为 0 时终止
        \end{itemize}
    \end{itemize}

    \textbf{构造一个整数 $n$ 的 $b$ 进制展开式}
    \begin{itemize}
        \item 伪代码
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.8\textwidth]{zs2.png}
        \end{figure}
    \end{itemize}

    \textbf{构造一个整数 $n$ 的 $b$ 进制展开式}
    \begin{itemize}
        \item 例：求 $12345_{10}$ 的八进制展开式
        \begin{align*}
        12345 &= 8 \cdot 1543 + 1 \\
        1543 &= 8 \cdot 192 + 7 \\
        192 &= 8 \cdot 24 + 0 \\
        24 &= 8 \cdot 3 + 0 \\
        3 &= 8 \cdot 0 + 3 \\
        12345_{10} &= 30071_{8}
        \end{align*}
    \end{itemize}
\end{definition}

\begin{definition}
    \textbf{二进制、八进制、十六进制展开式之间的转换}
    \begin{itemize}
        \item 每个八进制数字对应一组三位二进制数字
        \item 每个十六进制数字对应一组四位二进制数字
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{zs3.png}
    \end{figure}

    \textbf{二进制转换为}
    \begin{itemize}
        \item 十进制：按位权展开计算
        \item 八进制：从右向左按 3 个一组分组，每组按位权展开计算
        \item 十六进制：从右向左按 4 个一组分组，每组按位权展开计算
    \end{itemize}

    \textbf{转换为二进制}
    \begin{itemize}
        \item 十进制：二进制展开算法
        \item 八进制：每位上的数转换为对应的 3 位二进制数
        \item 十六进制：每位上的数转换为对应的 4 位二进制数
    \end{itemize}

    \textbf{二进制、八进制、十六进制展开式之间的转换}
    \begin{itemize}
        \item 例1：求 $11\,1110\,1011\,1100_2$ 的八进制和十六进制展开式
        \begin{align*}
        11\,111\,010\,111\,100_2 &= 3\,7\,2\,7\,4_8 \\
        11\,1110\,1011\,1100_2 &= 3\,E\,B\,C_{16}
        \end{align*}
        \item 例2：求 $765_8$ 和 $A8D_{16}$ 的二进制展开式
        \begin{align*}
        765_8 &= 111\,110\,101_2 \\
        A8D_{16} &= 1010\,1000\,1101_2
        \end{align*}
    \end{itemize}

    \textbf{十六进制与八进制之间的转换}
    \begin{itemize}
        \item 通过二进制间接转换
        \item 三位十六进制数对应于一个四位八进制数
        \item 例：求 $3EBC_{16}$ 的八进制展开式
        \begin{align*}
        3EBC_{16} &= 3 \cdot 16^3 + 14 \cdot 16^2 + 11 \cdot 16^1 + 12 \cdot 16^0 \\
        &= 16060_{10} = 37274_8 \\
        3EBC_{16} &= 11\,1110\,1011\,1100_2 = 11\,111\,010\,111\,100_2 = 3\,7\,2\,7\,4_8
        \end{align*}
    \end{itemize}
\end{definition}

\subsection{整数的运算算法}

\begin{definition}
    \textbf{整数的二进制加法}
    \begin{itemize}
        \item 设 $a = (a_{n-1}a_{n-2} \cdots a_1a_0)_2$, $b = (b_{n-1}b_{n-2} \cdots b_1b_0)_2$
        \item $a + b = (s_ns_{n-1}s_{n-2} \cdots s_1s_0)_2$
        \item $a_0 + b_0 = s_0 + 2c_0$
        \item $a_1 + b_1 + c_0 = s_1 + 2c_1$
        \item $\cdots$
        \item $a_{n-1} + b_{n-1} + c_{n-2} = s_{n-1} + 2c_{n-1}$
        \item $c_{n-1} = s_n$
    \end{itemize}

    \textbf{例：}
    \begin{itemize}
        \item $a = 1110_2$, $b = 1011_2$
        \[
    \begin{array}{cccccc}
      & 1 & 1 & 1 & 0 & (a_i) \\
    + & 1 & 0 & 1 & 1 & (b_i) \\
    \hline
    0 & 1 & 1 & 0 &   & \quad (c_{i-1}) \\
    1 & 1 & 0 & 0 & 1 & \quad (s_i)
    \end{array}
    \]
    \end{itemize}

    \textbf{整数的二进制加法}
    \begin{itemize}
        \item 算法复杂度为 $O(n)$
    \end{itemize}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{zg1.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{整数的二进制乘法}
    \begin{itemize}
        \item 设 $a = (a_{n-1}a_{n-2} \cdots a_1a_0)_2$, $b = (b_{n-1}b_{n-2} \cdots b_1b_0)_2$
        \item $ab = a \cdot (b_{n-1}2^{n-1} + b_{n-2}2^{n-2} + \cdots + b_12^1 + b_02^0)$
        \item $= b_{n-1}(2^{n-1}a) + b_{n-2}(2^{n-2}a) + \cdots + b_1(2^1a) + b_0(2^0a)$
        \item $= c_{n-1} + c_{n-2} + \cdots + c_1 + c_0$
    \end{itemize}

    \textbf{例：}
    \begin{itemize}
        \item $a = (110)_2$, $b = (101)_2$
        \item $ab = (11110)_2$
        \[
        \begin{array}{cccccc}
          &  & 1 & 1 & 0 & a \\
        \times &  & 1 & 0 & 1 & b \\
        \hline
          &   & 1 & 1 & 0 & c_0 \\
          & 0 & 0 & 0 & 0 & c_1 \\
        1 & 1 & 0 & 0 & 0 & c_2 \\
        \hline
        1 & 1 & 1 & 1 & 0 & ab
        \end{array}
        \]
    \end{itemize}

    \textbf{整数的二进制乘法}
    \begin{itemize}
        \item 算法复杂度为 $O(n^2)$
        \item 更高效的算法 $O(n^{1.585})$
    \end{itemize}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{zg2.png}
    \end{figure}
\end{definition}

\begin{definition}
    \textbf{整数的 div 和 mod 算法}
    \begin{itemize}
        \item 算法复杂度为 $O(q \log a)$
        \item 更高效的算法 $O(\log a \log d) = O(n^2)$
    \end{itemize}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{zg3.png}
    \end{figure}
\end{definition}

\subsection{模指数运算}

\begin{definition}
    \textbf{在密码学中经常需要计算 $b^n \mod m$}
    \begin{itemize}
        \item 其中 $b, n, m$ 都是大整数，如何快速计算非常重要
        \item 先计算 $b^n$ 再取余数的方法是不可行的，因为 $b^n$ 是非常大的整数
        \item 利用 $b^{k+1} = b \cdot b^k \mod m$ 也不可行，因为需要 $n - 1$ 次乘法
    \end{itemize}

    \textbf{可以利用 $n$ 的二进制展开来进行快速计算}
    \begin{itemize}
        \item 令 $n = (a_{k-1}a_{k-2} \cdots a_1a_0)_2$ 则
        \[
        b^n = b^{a_{k-1} \cdot 2^{k-1} + \cdots + a_1 \cdot 2 + a_0} = b^{2^{k-1}a_{k-1}} b^{2^{k-2}a_{k-2}} \cdots b^{2^1a_1} b^{a_0}
        \]
        \item 只需依次计算 $b, b^2, b^4 = (b^2)^2, b^8 = (b^4)^2, \cdots$
        \item 然后将 $a_j = 1$ 的对应项相乘即可
        \[
        a^b \mod m = (a \mod m) (b \mod m) \mod m
        \]
    \end{itemize}

    \textbf{例：}
    \begin{itemize}
        \item 计算 $3^{11} \mod 15$
        \item 因为 $11 = (1011)_2$，所以
        \[
        3^{11} = 3^{8} 3^{2} 3^{1} = 6561 \times 9 \times 3 = 177147
        \]
        \item $3^{11} \mod 15 = 177147 \mod 15 = 12$
        \item $3^{11} \mod 15 = (3^{8} \mod 15) \cdot (3^{2} \mod 15) \cdot (3^{1} \mod 15) \mod 15$
        \[
        = (6 \times 9 \mod 15) \times 3 \mod 15 = 9 \times 3 \mod 15 = 12
        \]
    \end{itemize}
    \[
        \colorbox{yellow}{$
            \begin{array}{l}
                3^1 \mod 15 = 3 \\
                3^2 \mod 15 = 9 \\
                3^4 \mod 15 = 6 \\
                3^8 \mod 15 = 6
            \end{array}
        $}
        \]
    \textbf{例：}
    \begin{itemize}
                \item 计算 $3^{644} \mod 645$
                \item 因为 $644 = (1010000100)_2$，所以
                \[
                3^{644} = 3^{512} \cdot 3^{128} \cdot 3^4 = 3^{2^9} \cdot 3^{2^7} \cdot 3^{2^2}
                \]
                \item 依次计算：
                \[
                \begin{aligned}
                    3^1 &\mod 645 = 3 \\
                    3^2 &\mod 645 = 9 \\
                    3^4 &\mod 645 = 81 \\
                    3^8 &\mod 645 = 6561 \mod 645 = 81 \\
                    3^{16} &\mod 645 = 81^2 \mod 645 = 6561 \mod 645 = 81 \\
                    3^{32} &\mod 645 = 81^2 \mod 645 = 6561 \mod 645 = 81 \\
                    3^{64} &\mod 645 = 81^2 \mod 645 = 6561 \mod 645 = 81 \\
                    3^{128} &\mod 645 = 81^2 \mod 645 = 6561 \mod 645 = 81 \\
                    3^{256} &\mod 645 = 81^2 \mod 645 = 6561 \mod 645 = 81 \\
                    3^{512} &\mod 645 = 81^2 \mod 645 = 6561 \mod 645 = 81 \\
                \end{aligned}
                \]
                \item $3^{644} \mod 645 = (3^{512} \mod 645) \cdot (3^{128} \mod 645) \cdot (3^4 \mod 645) \mod 645$
                \[
                = 81 \cdot 81 \cdot 81 \mod 645 = 531441 \mod 645 = 81
                \]
            \end{itemize}
            \[
            \colorbox{yellow}{$
                \begin{array}{l}
                    3^1 \mod 645 = 3 \\
                    3^2 \mod 645 = 9 \\
                    3^4 \mod 645 = 81 \\
                    3^8 \mod 645 = 81 \\
                    3^{16} \mod 645 = 81 \\
                    3^{32} \mod 645 = 81 \\
                    3^{64} \mod 645 = 81 \\
                    3^{128} \mod 645 = 81 \\
                    3^{256} \mod 645 = 81 \\
                    3^{512} \mod 645 = 81 \\
                    3^{644} \mod 645 = 81
                \end{array}
            $}
            \]
\end{definition}

\begin{definition}
• 模指数运算算法
– 算法复杂度为 $O((\log m)^2 \log n)$
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{zg4.png}
\end{figure}
\end{definition}


\section{素数和最大公约数}

\subsection{素数}
\begin{definition}
    \textbf{算术基本定理（Fundamental Theorem of Arithmetic）}
    \begin{itemize}
        \item 每个大于 1 的整数都可以唯一地写为一个素数，或者两个或多个素数的乘积
        \item 其中素数因子以非递减序排列
    \end{itemize}

    \textbf{素因子分解：}
    \begin{itemize}
        \item $100 = 2 ∙ 2 ∙ 5 ∙ 5 = 2^2 ∙ 5^2$
        \item $641 = 641$
        \item $999 = 3 ∙ 3 ∙ 3 ∙ 37 = 3^3 ∙ 37$
        \item $1024 = 2^{10}$
    \end{itemize}
\end{definition}

\subsection{试除法}
\begin{definition}
    \begin{itemize}
        \item 证明一个给定的整数是素数，是非常重要的
        \item 定理：
        \begin{itemize}
            \item 如果 $n$ 是一个合数，那么 $n$ 一定有一个小于或等于 $\sqrt{n}$ 的素因子
        \end{itemize}
        \item 试除法（Trial Division）
        \begin{itemize}
            \item 如果一个整数 $n$ 不能被小于或等于 $\sqrt{n}$ 的素数整除，则 $n$ 是素数
            \item 蛮力算法，穷举所有小于或等于 $\sqrt{n}$ 的素数
        \end{itemize}
    \end{itemize}

    \textbf{例3}
    \begin{itemize}
        \item 证明 101 是素数
    \end{itemize}

    \textbf{例4}
    \begin{itemize}
        \item 求 7007 的素因子分解
    \end{itemize}
\end{definition}

\subsection{寻找素数}

\begin{definition}
    \textbf{寻找素数}
    \begin{itemize}
        \item 寻找不超过一个给定整数的所有素数
        \item 埃拉托斯特尼筛法（The Sieve of Eratosthenes）
        \begin{itemize}
            \item 给定一个整数 $n$，寻找不超过 $n$ 的素数
            \item 依次用从 2 到 $n$ 的素数，删掉那些能被该素数整除的数
        \end{itemize}
    \end{itemize}

    \textbf{例：不超过 100 的素数}\par
2,3,5,7,\par
11,13,17,19,\par
23,29,\par
31,37,\par
41,43,47,\par
53,59,\par
61,67,\par
71,73,79,\par
83,89,\par
97
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\textwidth]{sushu.png}
        \caption{不超过 100 的素数}
    \end{figure}
\cleardoublepage
    \textbf{素数的无限性}
    \begin{itemize}
        \item 长期以来人们就知道存在无限多个素数
        \item 欧几里得在《几何原本》中给出了一个优雅的证明，被认为是数学中最漂亮的证明之一
        \item 反证法，假设只有有限个素数 $p_1, p_2, \cdots, p_n$。
        \item 令 $Q = p_1p_2 \cdots p_n + 1$，根据算术基本定理，要么 $Q$ 是素数，要么 $Q$ 能写成两个或多个素数的乘积。
        \item 但没有一个素数 $p_i$ 可以整除 $Q$，因为若 $p_i \mid Q$ 则 $p_i$ 整除 $Q - p_1p_2 \cdots p_n = 1$。
        \item 所以存在一个不在 $p_1, p_2, \cdots, p_n$ 中的素数，矛盾。
    \end{itemize}
\end{definition}

\subsection{梅森素数}

\begin{definition}
    \textbf{梅森素数}
    \begin{itemize}
        \item 由于大素数在密码学中的重要性，人们不断追求发现更大的素数
        \item 梅森素数（Mersenne Primes）
        \begin{itemize}
            \item 形如 $2^p - 1$ 的素数，其中 $p$ 也是素数
            \item 注意：当 $p$ 不是素数时，$2^p - 1$ 不可能是素数（why？）
        \end{itemize}
        \item 例：
        \begin{itemize}
            \item $2^2 - 1 = 3$
            \item $2^3 - 1 = 7$
            \item $2^5 - 1 = 31$
            \item $2^7 - 1 = 127$
            \item $2^{11} - 1 = 2047 = 23 \times 89$，不是素数
        \end{itemize}
    \end{itemize}

    \textbf{完全数（Perfect Number）}
    \begin{itemize}
        \item 一个正整数如果正好等于它的所有真因子之和，则称为完全数
        \item 例：
        \begin{itemize}
            \item $6 = 1 + 2 + 3$
            \item $28 = 1 + 2 + 4 + 7 + 14$
            \item $496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248$
            \item $8192 = 1 + 2 + 4 + 8 + 16 + 32 + 127 + 254 + 508 + 1016 + 2032 + 4064$
        \end{itemize}
    \end{itemize}

    \textbf{梅森素数与完全数}
    \begin{itemize}
        \item 欧几里得《几何原本》：如果 $2^p - 1$ 为素数，则 $2^{p-1} \cdot (2^p - 1)$ 为完全数
        \item 每发现一个梅森素数就发现一个对应的完全数
        \item 欧几里得-欧拉定理（Euclid-Euler Theorem）
        \begin{itemize}
            \item 一个偶数是完全数当且仅当其具有 $2^{p-1} \cdot (2^p - 1)$ 的形式，其中 $2^p - 1$ 为素数
        \end{itemize}
        \item 开放问题：
        \begin{itemize}
            \item 是否存在奇完全数？是否有无限多个完全数（梅森素数）？
        \end{itemize}
    \end{itemize}
\end{definition}

\subsection{素数的分布}

\begin{definition}
    \textbf{素数的分布}
    \begin{itemize}
        \item 数学家们感兴趣的一个问题是：素数在整数中是如何分布的
        \item 素数定理（Prime Number Theorem）
        \begin{itemize}
            \item 当 $x$ 无限增长时，不超过 $x$ 的素数个数与 $\frac{x}{\ln x}$ 之比趋近于 1
        \end{itemize}
        \item 素数定理给出了不超过 $x$ 的素数个数的渐近估计
        \begin{itemize}
            \item 不超过 $x$ 的素数个数可以近似为 $\frac{x}{\ln x}$
            \item 随机选择一个不超过 $n$ 的整数是素数的可能性为 $\frac{\frac{n}{\ln n}}{n} = \frac{1}{\ln n}$
            \item 素数的分布随着 $n$ 的增长而逐渐稀疏
        \end{itemize}
    \end{itemize}

    \textbf{素数有无限多的证明可以容易地推广到等差数列 $4k + 3$ ($k = 1,2, \cdots$) 中}
    \begin{itemize}
        \item 考虑整数 $Q = 4q_1q_2 \cdots q_n - 1$，其中 $q_i$ 为数列 $4k + 3$ 中的所有素数
        \item $q_i$ 不能整除 $Q$，$Q$ 也在数列 $4k + 3$ 中
        \item $Q$ 要么为素数，要么包含形如 $4k + 3$ 的素因子（两个 $4k + 1$ 形式整数的乘积还是 $4k + 1$ 形式）
    \end{itemize}

    \textbf{19世纪，狄利克雷证明了：}
    \begin{itemize}
        \item 当 $a$ 和 $b$ 不存在大于 1 的公因子时，每个等差数列 $ak + b$ ($k = 1,2, \cdots$) 中都有无限多个素数。
    \end{itemize}

    \textbf{是否存在仅由素数构成的较长的等差数列呢？}
    \begin{itemize}
        \item 5个（$a = 6$）：5, 11, 17, 23, 29
        \item 10个（$a = 210$）：199, 409, 619, 829, 1039, 1249, 1459, 1669, 1879, 2089
    \end{itemize}

    \textbf{20世纪30年代，Paul Erdős提出了一个猜想：}
    \begin{itemize}
        \item 对于任意正整数 $n$ 都存在一个长度为 $n$ 仅由素数构成的等差数列。
    \end{itemize}

    \textbf{2004年陶哲轩和Ben Green证明了该猜想（Green-Tao定理）}
    \begin{itemize}
        \item 非构造性证明
    \end{itemize}
\end{definition}

\subsection{素数的猜想和开放问题}

\begin{definition}

    \textbf{哥德巴赫猜想（Goldbach’s Conjecture）}
    \begin{itemize}
        \item 每个大于 2 的偶数是两个素数之和（欧拉版本）
        \item 每个大于 5 的整数是三个素数之和（原始版本）
    \end{itemize}

    \textbf{弱哥德巴赫猜想}
    \begin{itemize}
        \item 每个大于 5 的奇数是三个素数之和
    \end{itemize}

    \textbf{孪生素数猜想（Twin Prime Conjecture）}
    \begin{itemize}
        \item 存在无限多对孪生素数（相差 2 的一对素数）
        \item 例如：3,5 、5,7 、11,13 、17,19 、29,31 、41,43 、59,61 、71,73
        \item 已知最大的孪生素数（388342位）：$2996863034895 \times 2^{1290000} \pm 1$
        \item 陈景润（1966）：存在无限多对整数 $(p, p + 2)$，其中 $p$ 为素数，$p + 2$ 为素数或两个素数的乘积
    \end{itemize}

    \textbf{Polignac's Conjecture}
    \begin{itemize}
        \item 存在无限多对相差为 $2k$ 的素数对
        \item $k = 1$: twin primes, $k = 2$: cousin primes, $k = 3$: sexy primes
    \end{itemize}

    \textbf{有界间隔猜想（Bounded Gap Conjecture）}
    \begin{itemize}
        \item 存在无限多对相差为 $N$ 的素数对
        \item 张益唐（2013）：$N < 7000\text{万}$
        \item 陶哲轩（2014）：$N \leq 246$
        \item 陶哲轩等：如果 Elliott–Halberstam 猜想成立，$N \leq 6$
    \end{itemize}
\end{definition}

\subsection{最大公约数和最小公倍数}

\begin{definition}
    \begin{itemize}
        \item 最大公约数（Great Common Divisor）
        \begin{itemize}
            \item 令 $a$ 和 $b$ 为非全为零的整数，满足 $d \mid a$ 和 $d \mid b$ 的最大整数 $d$ 称为 $a$ 和 $b$ 的最大公约数，记为 $\gcd(a, b)$
        \end{itemize}
        \item 互素（Relative Prime/Mutually Prime/Coprime）
        \begin{itemize}
            \item 整数 $a$ 和 $b$ 是互素的，如果 $a$ 和 $b$ 的最大公约数为 1
        \end{itemize}
        \item 两两互素（Pairwise Relative Prime）
        \begin{itemize}
            \item 整数 $a_1, a_2, \cdots, a_n$ 是两两互素的，如果 $\gcd(a_i, a_j) = 1$ 当 $1 \leq i,j \leq n$
        \end{itemize}
        \item 最小公倍数（Least Common Multiple）
        \begin{itemize}
            \item 令 $a$ 和 $b$ 为正整数，满足 $a \mid m$ 和 $b \mid m$ 的最小正整数 $m$ 称为 $a$ 和 $b$ 的最小公倍数，记为 $\mathrm{lcm}(a, b)$
        \end{itemize}
        \item 定理5：
        \begin{itemize}
            \item 令 $a$ 和 $b$ 为正整数，则
            \[
            ab = \gcd(a, b) \cdot \mathrm{lcm}(a, b)
            \]
        \end{itemize}
    \end{itemize}

    \textbf{素因子分解法求最大公约数和最小公倍数}
    \[
    a = p_1^{a_1} p_2^{a_2} \cdots p_n^{a_n}, \quad a_i \geq 0
    \]
    \[
    b = p_1^{b_1} p_2^{b_2} \cdots p_n^{b_n}, \quad b_i \geq 0
    \]
    \[
    \gcd(a, b) = p_1^{\min(a_1, b_1)} p_2^{\min(a_2, b_2)} \cdots p_n^{\min(a_n, b_n)}
    \]
    \[
    \mathrm{lcm}(a, b) = p_1^{\max(a_1, b_1)} p_2^{\max(a_2, b_2)} \cdots p_n^{\max(a_n, b_n)}
    \]
    \item 求一个整数的素因子分解，目前还没有高效的算法
\end{definition}

\subsection{欧几里得算法}

\begin{definition}
    \textbf{欧几里得算法（Euclidean Algorithm）}
    \begin{itemize}
        \item 引理1：如果 $a = bq + r$，则 $\gcd(a, b) = \gcd(b, r)$
        \item 辗转相除法
        \item 示例：
        \begin{itemize}
            \item 求 $\gcd(287, 91)$
            \[
            287 = 91 \times 3 + 14
            \]
            \[
            91 = 14 \times 6 + 7
            \]
            \[
            14 = 7 \times 2 + 0
            \]
            \item 所以 $\gcd(287, 91) = \gcd(91, 14) = \gcd(14, 7) = 7$
        \end{itemize}
        \item 欧几里得算法
        \begin{itemize}
            \item 算法复杂度为 $O(\log b)$
            \item 伪代码：
            \begin{verbatim}
                procedure euclidean_gcd(a, b: 正整数)
                    x = a
                    y = b
                    while y != 0
                        r = x mod y
                        x = y
                        y = r
                    return x
                \end{verbatim}
        \end{itemize}
    \end{itemize}
\end{definition}

\subsection{最大公约数的性质}

\begin{definition}
    \begin{itemize}
        \item 定理（辗转相减）
        \begin{itemize}
            \item 设 $a, b \in \mathbb{Z}^+$，$a > b$，$\gcd(a, b) = \gcd(a, a - b)$
        \end{itemize}
        \item 定理（辗转相除）
        \begin{itemize}
            \item 设 $a, b \in \mathbb{Z}^+$，$a > b$，$\gcd(a, b) = \gcd(a, a \mod b)$
        \end{itemize}
        \item 定理6（线性合成）
        \begin{itemize}
            \item 如果 $a, b \in \mathbb{Z}^+$，则 $\exists s, t \in \mathbb{Z}$ 使得 $\gcd(a, b) = sa + tb$
            \item $s$ 和 $t$ 称为 $a$ 和 $b$ 的贝祖系数（Bézout Coefficient）
        \end{itemize}
    \end{itemize}

    \textbf{贝祖引理（Bézout’s Lemma）}
    \begin{itemize}
        \item 贝祖恒等式（Bézout’s Identity）
        \item 证明：
        \begin{itemize}
            \item 令 $S = \{ax + by \mid x, y \in \mathbb{Z}^+\}$，则 $S$ 非空且有最小元素（良序性公理）。
            \item 设最小元素为 $d = as + bt$，下面证明 $d = \gcd(a, b)$。
            \item 根据除法算法，设 $a = dq + r, 0 \leq r < d$。
            \item 因为 $r = a - dq = a - q(as + bt) = a(1 - qs) + b(-qt)$，所以 $r \in S \cup \{0\}$。
            \item 但是 $d$ 是 $S$ 中的最小元素，而 $0 \leq r < d$，所以 $r = 0$，因此 $d \mid a$。
            \item 同理可证 $d \mid b$。
            \item 设 $c \mid a$ 且 $c \mid b$，则 $\exists k_1, k_2 \in \mathbb{Z}$，$a = k_1c, b = k_2c$。
            \item 那么 $d = as + bt = k_1cs + k_2ct = c(k_1s + k_2t)$，所以 $c \mid d$。
            \item 又因为 $d > 0$，所以 $d \geq c$。
            \item 所以 $\gcd(a, b) = d$。
        \end{itemize}
    \end{itemize}

    \textbf{求解贝祖恒等式}
    \begin{itemize}
        \item 欧几里得算法回溯
        \item 示例：$\gcd(287, 91) = 7$
        \[
            287 = 91 \times 3 + 14
            \]
            \[
            91 = 14 \times 6 + 7
            \]
            \[
            14 = 7 \times 2 + 0
            \]
        \[
        7 = 91 - 14 \times 6 = 91 - (287 - 91 \times 3) \times 6 = 91 \times 19 + 287 \times (-6)
        \]
    \end{itemize}
\end{definition}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{oujiex.png}
    \caption{扩展欧几里得算法}
\end{figure}


\begin{definition}
    \textbf{贝祖定理有很多应用}
    \begin{itemize}
        \item 引理2：
        \begin{itemize}
            \item 如果 $a, b, c$ 为正整数使得 $\gcd(a, b) = 1$ 且 $a \mid bc$，则 $a \mid c$
        \end{itemize}
        \item 证明：
        \begin{itemize}
            \item 由于 $\gcd(a, b) = 1$ 所以根据贝祖定理，存在整数 $s$ 和 $t$ 使得 $sa + tb = 1$
            \item 等式两边同乘以 $c$ 得 $sac + tbc = c$
            \item 因为 $a \mid sac$ 且 $a \mid tbc$，所以 $a \mid c$
        \end{itemize}
    \end{itemize}

    \textbf{定理7：}
    \begin{itemize}
        \item 令 $m$ 为正整数，令 $a, b, c$ 为整数。如果 $ac \equiv bc \pmod m$ 且 $\gcd(c, m) = 1$，则 $a \equiv b \pmod m$
        \item 证明：
        \begin{itemize}
            \item 因为 $ac \equiv bc \mod m$ 所以 $m \mid (ac - bc) = c(a - b)$
            \item 根据引理2，因为 $\gcd(c, m) = 1$，所以 $m \mid (a - b)$
            \item 所以 $a \equiv b \mod m$
            \item 如果 $\gcd(c, m) = d$ 会如何？
        \end{itemize}
    \end{itemize}

    \textbf{同余式两边可以同时除以与 $m$ 互素的整数}
    \begin{itemize}
        \item 例1：
        \begin{itemize}
            \item $14 \equiv 8 \mod 6$
            \item 两边同时除以 2，同余式不成立：$7 \not\equiv 4 \mod 6$
        \end{itemize}
        \item 例2：
        \begin{itemize}
            \item $14 \equiv 8 \mod 3$
            \item 两边同时除以 2，同余式成立：$7 \equiv 4 \mod 3$
        \end{itemize}
    \end{itemize}

    \textbf{引理3：}
    \begin{itemize}
        \item 如果 $p$ 为素数，且 $p \mid a_1a_2 \cdots a_n$，其中 $a_i$ 为整数，则存在 $i$ 使得 $p \mid a_i$
    \end{itemize}

    \textbf{证明正整数素因子分解的唯一性（算术基本定理之一部分）：}
    \begin{itemize}
        \item 假设正整数 $n$ 存在两种不同的素因子分解 $p_1p_2 \cdots p_s$ 和 $q_1q_2 \cdots q_t$
        \item 去掉所有共同的素数，可得 $p_{i1}p_{i2} \cdots p_{iu} = q_{j1}q_{j2} \cdots q_{jv}$
        \item 由引理3可知，存在 $k$ 使得 $p_{i1} \mid q_{jk}$
        \item 但是 $p_i$ 和 $q_j$ 都是素数，矛盾
    \end{itemize}
\end{definition}



\section{求解同余方程}

\subsection{同余方程}

\begin{definition}
    \textbf{同余的定义：}
    \begin{itemize}
        \item 设 $a, b \in \mathbb{Z}$, $m \in \mathbb{Z}^+$
        \[
        a \equiv b \pmod{m} \iff m \mid (a - b) \iff \exists k \in \mathbb{Z}, a = b + km \iff 
        \begin{cases}
            a = q_1m + r_1 & 0 \leq r_1 < m \\
            b = q_2m + r_2 & 0 \leq r_2 < m \\
            r_1 = r_2
        \end{cases}
        \]
    \end{itemize}

    \textbf{同余的性质：}
    \begin{itemize}
        \item 设 $a, b \in \mathbb{Z}$, $m \in \mathbb{Z}^+$
        \begin{enumerate}
            \item $a \equiv a \pmod{m}$
            \item $a \equiv b \pmod{m} \implies b \equiv a \pmod{m}$
            \item $a \equiv b \pmod{m}$, $b \equiv c \pmod{m} \implies a \equiv c \pmod{m}$
            \item $a \equiv b \pmod{m}$, $c \equiv d \pmod{m} \implies a + c \equiv b + d \pmod{m}$
            \item $a \equiv b \pmod{m}$, $c \equiv d \pmod{m} \implies ac \equiv bd \pmod{m}$
            \item $ac \equiv bd \pmod{m}$, $c \equiv d \pmod{m}$, $\gcd(c, m) = 1 \implies a \equiv b \pmod{m}$
            \item $ac \equiv bc \pmod{m}$, $\gcd(c, m) = d \implies ad \equiv bd \pmod{m}$
            \item $a \equiv b \pmod{m}$, $d \in \mathbb{Z}^+$, $d \mid a$, $d \mid b$, $d \mid m \implies \frac{a}{d} \equiv \frac{b}{d} \pmod{\frac{m}{d}}$
            \item $a \equiv b \pmod{m}$, $m' \mid m \implies a \equiv b \pmod{m'}$
        \end{enumerate}
    \end{itemize}
\end{definition}

\subsection{线性同余方程}

\begin{definition}
    \textbf{线性同余方程（Linear Congruence）}
    \begin{itemize}
        \item 具有形式 $ax \equiv b \pmod{m}$ 的同余方程
        \item 其中 $m \in \mathbb{Z}^+$，$a, b \in \mathbb{Z}$，$x$ 为变量
    \end{itemize}

    \textbf{模 $m$ 的逆（inverse modulo $m$）}
    \begin{itemize}
        \item 一个整数 $\bar{a}$ 如果满足 $\bar{a}a \equiv 1 \pmod{m}$ 则称 $\bar{a}$ 为 $a$ 模 $m$ 的逆
        \item 如果 $a$ 模 $m$ 的逆 $\bar{a}$ 存在，则在线性同余方程两边同乘以 $\bar{a}$ 可得
        \[
        x \equiv \bar{a}ax \equiv \bar{a}b \pmod{m}
        \]
    \end{itemize}

    \textbf{线性同余方程的解}
    \begin{itemize}
        \item 具有形式 $ax \equiv b \pmod{m}$ 的同余方程
        \item 其中 $m \in \mathbb{Z}^+$，$a, b \in \mathbb{Z}$，$x$ 为变量
        \item 什么时候有解？ $\gcd(a, m) \mid b$
        \item 什么时候无解？ $\gcd(a, m) \nmid b$
        \item 如何求解？有几个解？ 恰有 $\gcd(a, m)$ 个解
    \end{itemize}

    \textbf{定理1：}
    \begin{itemize}
        \item 如果 $a$ 和 $m$ 为互素的整数且 $m > 1$，则 $a$ 模 $m$ 的逆存在，而且是模 $m$ 唯一的（存在唯一的正整数 $\bar{a} < m$ 是 $a$ 模 $m$ 的逆，$a$ 模 $m$ 的逆都与 $\bar{a}$ 模 $m$ 同余）。
    \end{itemize}

    \textbf{证明：}
    \begin{itemize}
        \item 因为 $a$ 和 $m$ 互素，根据贝祖定理，存在整数 $s$ 和 $t$ 使得 $sa + tm = 1$
        \item 因为 $tm \equiv 0 \pmod{m}$，所以 $sa \equiv 1 \pmod{m}$
        \item 因此 $s$ 为 $a$ 模 $m$ 的逆
        \item 唯一性如何证明？
    \end{itemize}

    \textbf{如何求 $a$ 模 $m$ 的逆？}
    \begin{itemize}
        \item 蛮力法：
        \begin{itemize}
            \item 寻找一个 $a$ 的倍数，它比 $m$ 的倍数大 1
        \end{itemize}
        \item 示例1：
        \begin{itemize}
            \item 求 3 模 7 的逆
            \item $3 \times 1 = 3$，$3 \times 2 = 6$，$3 \times 3 = 9$，$3 \times 4 = 12$，$3 \times 5 = 15$
            \item 所以 3 模 7 的逆为 5
        \end{itemize}
        \item 可以用扩展欧几里得算法来求模 $m$ 的逆
        \item 示例2：
        \begin{itemize}
            \item 求 3 模 7 的逆
            \item 用欧几里得算法求 $\gcd(3, 7)$
            \[
            7 = 3 \times 2 + 1
            \]
            \[
            3 = 1 \times 3
            \]
            \item 所以 $1 = 7 \times 1 + 3 \times (-2)$，即 3 的贝祖系数为 -2
            \item 所以 -2 是 3 模 7 的逆
            \item 模 7 余 -2 的整数都是 3 模 7 的逆，如 5, 12
        \end{itemize}
    \end{itemize}

    \textbf{示例3：}
    \begin{itemize}
        \item 求线性同余方程 $3x \equiv 4 \pmod{7}$
        \item 因为 5 是 3 模 7 的逆，在方程两边同乘以 5 可得 $15x \equiv 20 \pmod{7}$
        \item 因为 $15 \equiv 1 \pmod{7}$，所以 $x \equiv 20 \equiv 6 \pmod{7}$
        \item 验证 $x \equiv 6 \pmod{7}$ 是原方程的解
        \[
        3x \equiv 3 \cdot 6 = 18 \equiv 4 \pmod{7}
        \]
        \item 所有使得 $x \equiv 6 \pmod{7}$ 的整数都是原方程的解，例如 6, 13, 20, -1, -8, …
    \end{itemize}

    \textbf{示例4：}
    \begin{itemize}
        \item 求线性同余方程 $6x \equiv 8 \pmod{14}$
        \item 方程等价于 $3x \equiv 4 \pmod{7}$
        \item 已知 $x \equiv 6 \pmod{7}$ 是方程 $3x \equiv 4 \pmod{7}$ 的解
        \item 所以 $x \equiv 6 \pmod{14}$、$x \equiv 13 \pmod{14}$ 都是原方程的解
    \end{itemize}
\end{definition}

\subsection{中国剩余定理}

\begin{definition}
    \textbf{《孙子算经》}
    \begin{itemize}
        \item 有物不知其数，三分之余二，五分之余三，七分之余二，此物几何？
    \end{itemize}

    \textbf{线性同余方程组}
    \[
    \begin{cases}
        x \equiv 2 \pmod{3} \\
        x \equiv 3 \pmod{5} \\
        x \equiv 2 \pmod{7}
    \end{cases}
    \]

    \textbf{中国剩余定理（Chinese Remainder Theorem）}
    \begin{itemize}
        \item 令 $m_1, m_2, \cdots, m_n$ 为大于 1 的两两互素的正整数，而 $a_1, a_2, \cdots, a_n$ 是任意整数。
        \item 则同余方程组
        \[
        \begin{cases}
            x \equiv a_1 \pmod{m_1} \\
            x \equiv a_2 \pmod{m_2} \\
            \vdots \\
            x \equiv a_n \pmod{m_n}
        \end{cases}
        \]
        有唯一的模 $m = m_1m_2 \cdots m_n$ 的解。（即存在一个满足 $0 \leq x < m$ 的解 $x$，所有的解都与 $x$ 模 $m$ 同余）
    \end{itemize}

    \textbf{证明：}
    \begin{itemize}
        \item 我们采用构造法证明解的存在性
        \item 令 $M_k = \frac{m}{m_k}$，$k = 1, 2, \cdots, n$
        \item 因为 $\gcd(m_k, M_k) = 1$，由4.4.2节定理1可知，存在整数 $y_k$ 为 $M_k$ 模 $m_k$ 的逆，使得 $M_ky_k \equiv 1 \pmod{m_k}$
        \item 令 $x = a_1M_1y_1 + a_2M_2y_2 + \cdots + a_nM_ny_n$
        \item 因为 $M_j \equiv 0 \pmod{m_k}$，$j \neq k$，而 $M_ky_k \equiv 1 \pmod{m_k}$，所以
        \[
        x \equiv a_kM_ky_k \equiv a_k \pmod{m_k}
        \]
        \item 所以 $x$ 是方程组的解
        \item 要证明唯一性，假设 $x$ 和 $y$ 都是方程组的解，只需证明 $m \mid (x - y)$
        \item 设 $m$ 的素因子分解为 $m = p_1^{r_1}p_2^{r_2} \cdots p_s^{r_s}$
        \item 因为 $m_i$ 两两互素，所以 $p_k$ 只能是某一个 $m_i$ 的素因子（记为 $m_{i_k}$）
        \item 而且 $p_k$ 在 $m_{i_k}$ 中的幂次也是 $r_k$
        \item 因为 $m_i \mid (x - y)$，$i = 1, 2, \cdots, n$ (why?)
        \item 所以 $p_k^{r_k} \mid (x - y)$，$k = 1, 2, \cdots, s$
        \item 所以 $m \mid (x - y)$
    \end{itemize}

    \textbf{示例1：}
    \begin{itemize}
        \item 求解方程组
        \[
        \begin{cases}
            x \equiv 2 \pmod{3} \\
            x \equiv 3 \pmod{5} \\
            x \equiv 2 \pmod{7}
        \end{cases}
        \]
        \item 令 $m = 3 \cdot 5 \cdot 7 = 105$，$M_1 = \frac{m}{3} = 35$，$M_2 = \frac{m}{5} = 21$，$M_3 = \frac{m}{7} = 15$
        \item $M_1$ 模 3 的逆为 2，$M_2$ 模 5 的逆为 1，$M_3$ 模 7 的逆为 1，所以
        \[
        x = a_1M_1y_1 + a_2M_2y_2 + a_3M_3y_3 = 2 \cdot 35 \cdot 2 + 3 \cdot 21 \cdot 1 + 2 \cdot 15 \cdot 1 = 233
        \]
        \item 方程组的解为 $x \equiv 233 \equiv 23 \pmod{105}$
    \end{itemize}

    \textbf{反向替换法（Back Substitution）}
    \begin{itemize}
        \item 利用同余的性质，将线性同余方程改写为等式，代入其他同余方程
    \end{itemize}

    \textbf{示例2：}
    \begin{itemize}
        \item 求解方程组
        \[
        \begin{cases}
            x \equiv 1 \pmod{5} \\
            x \equiv 2 \pmod{6} \\
            x \equiv 3 \pmod{7}
        \end{cases}
        \]
        \item 第一个同余方程等价于 $x = 5t + 1$，将其代入第二个同余方程可得
        \[
        5t + 1 \equiv 2 \pmod{6}
        \]
        \item 解得 $t \equiv 5 \pmod{6}$（why?）
        \item 该同余方程等价于 $t = 6u + 5$，代入等式 $x = 5t + 1$ 可得
        \[
        x = 30u + 26
        \]
        \item 将等式代入第三个同余方程，可得
        \[
        30u + 26 \equiv 3 \pmod{7}
        \]
        \item 解得 $u \equiv 6 \pmod{7}$（why?）
        \item 该同余方程等价于 $u = 7v + 6$，代入等式 $x = 30u + 26$ 可得
        \[
        x = 210v + 206
        \]
        \item 该等式等价于 $x \equiv 206 \pmod{210}$
    \end{itemize}
\end{definition}


\subsection{大整数的算术运算}

\begin{definition}
    \begin{itemize}
        \item 设 $m_1, m_2, \cdots, m_n$ 为两两互素的整数，令 $m = m_1m_2 \cdots m_n$
        \item 根据中国剩余定理，可以证明满足 $0 \leq a < m$ 的整数 $a$ 可唯一地表示为一个 $n$ 元组，其元素由 $a$ 除以 $m_i$ 的余数组成，即
        \[
        a = (a \mod m_1, a \mod m_2, \cdots, a \mod m_n)
        \]
        \item 示例：
        \[
        \begin{aligned}
            &m_1 = 3, m_2 = 4 \\
            &0 = (0, 0), 1 = (1, 1), 2 = (2, 2), 3 = (0, 3), 4 = (1, 0), 5 = (2, 1), \\
            &6 = (0, 2), 7 = (1, 3), 8 = (2, 0), 9 = (0, 1), 10 = (1, 2), 11 = (2, 3)
        \end{aligned}
        \]
    \end{itemize}

    \textbf{大整数算术运算}
    \begin{itemize}
        \item 选定模数 $m_1, m_2, \cdots, m_n$
        \item 将大整数表示为 $n$ 元组
        \item 在 $n$ 元组上进行运算
        \item 通过求解线性同余方程组将 $n$ 元组映射回大整数
        \item 可以计算超过计算机表示能力的大整数
        \item 对不同模数的计算可以并行操作，加快计算速度
    \end{itemize}

    \textbf{示例：}
    \begin{itemize}
        \item 假设计算机只能计算 100 以内的整数算术运算（结果不超过 10000）
        \item 选择模数 99, 98, 97, 95，则可以完成结果不超过 89403930 的整数运算
        \item 加法：
        \[
        \begin{aligned}
            &123684 = (33, 8, 9, 89) \\
            &413456 = (32, 92, 42, 16) \\
            &123684 + 413456 = (33 + 32, 8 + 92, 9 + 42, 89 + 16) \\
            &= (65 \mod 99, 100 \mod 98, 51 \mod 97, 105 \mod 95) \\
            &= (65, 2, 51, 10)
        \end{aligned}
        \]
        \item 求解方程组：
        \[
        \begin{cases}
            x \equiv 65 \pmod{99} \\
            x \equiv 2 \pmod{98} \\
            x \equiv 51 \pmod{97} \\
            x \equiv 10 \pmod{95}
        \end{cases}
        \]
        可得 $x$ = 537140
        \item 乘法：
        \[
        \begin{aligned}
            &1236 = (48, 60, 72, 1) \\
            &3456 = (90, 26, 61, 36) \\
            &1236 \times 3456 = (48 \times 90, 60 \times 26, 72 \times 61, 1 \times 36) \\
            &= (4320 \mod 99, 1560 \mod 98, 4392 \mod 97, 36 \mod 95) \\
            &= (63, 90, 27, 36)
        \end{aligned}
        \]
        \item 求解方程组：
        \[
        \begin{cases}
            x \equiv 63 \pmod{99} \\
            x \equiv 90 \pmod{98} \\
            x \equiv 27 \pmod{97} \\
            x \equiv 36 \pmod{95}
        \end{cases}
        \]
        可得 $x$ = 4271616
    \end{itemize}

    \textbf{模数的选择}
    \begin{itemize}
        \item 形如 $2^k - 1$ 的整数，其中 $k$ 为正整数
        \item 二进制模算术很容易进行
        \item 两两互素的整数也很容易找到
        \item $\gcd(2^a - 1, 2^b - 1) = 2^{\gcd(a, b)} - 1$
    \end{itemize}
\end{definition}

\subsection{费马小定理}

\begin{definition}
    \textbf{费马小定理（Fermat’s Little Theorem）}
    \begin{itemize}
        \item 如果 $p$ 为素数，$a$ 是一个不能被 $p$ 整除的整数，则
        \[
        a^{p-1} \equiv 1 \pmod{p}
        \]
        \item 进一步，对于每个整数 $a$ 都有
        \[
        a^p \equiv a \pmod{p}
        \]
        \item 费马小定理在计算整数的高次幂的模 $p$ 余数时非常有用
        \begin{itemize}
            \item 例如：$7^{222} = 7^{22 \cdot 10 + 2} = (7^{22})^{10} \cdot 7^2 \equiv 1^{10} \cdot 49 \equiv 5 \pmod{11}$
            \item 所以 $7^{222} \mod 11 = 5$
        \end{itemize}
    \end{itemize}

    \textbf{证明}
    \begin{itemize}
        \item 当 $p \nmid a$ 时，$0, a, 2a, 3a, \cdots, (p-1)a$ 中任意两个都不是模 $p$ 同余（否则 $p \mid a$）
        \item 因此 $a \cdot 2a \cdot 3a \cdot \cdots \cdot (p-1)a \equiv 1 \cdot 2 \cdot 3 \cdot \cdots \cdot (p-1) \pmod{p}$
        \item 即 $(p-1)! \cdot a^{p-1} \equiv (p-1)! \pmod{p}$
        \item 因为 $p$ 为素数，所以 $p \nmid (p-1)!$
        \item 因此 $\gcd(p, (p-1)!) = 1$，所以 $a^{p-1} \equiv 1 \pmod{p}$
        \item 当 $p \nmid a$ 时，由前面结果有 $a^p \equiv a \pmod{p}$
        \item 当 $p \mid a$ 时，显然有 $\forall n \in \mathbb{Z}^+$，$a^n \equiv 0 \pmod{p}$，所以 $a^p \equiv a \pmod{p}$
    \end{itemize}
\end{definition}

\subsection{伪素数}

\begin{definition}
    \textbf{伪素数（Pseudoprime）}
    \begin{itemize}
        \item 当整数 $n > 2$ 是素数时，由费马小定理可知
        \[
        2^{n-1} \equiv 1 \pmod{n}
        \]
        \item 反之是否成立呢？如果成立则上式可以用于判定素数
        \[
        2^{340} \equiv 1 \pmod{341}
        \]
        \item 令 $b$ 为一个正整数，如果 $n$ 是一个正合数且 $b^{n-1} \equiv 1 \pmod{n}$，则 $n$ 称为以 $b$ 为基数的伪素数
    \end{itemize}

    \textbf{伪素数可以用于素数测试}
    \begin{itemize}
        \item 给定一个整数 $n$，检查 $2^{n-1} \equiv 1 \pmod{n}$
        \item 如果 $n$ 不满足该同余式，则 $n$ 为合数
        \item 如果 $n$ 满足该同余式，则 $n$ 要么是素数，要么是以 2 为基数的伪素数
        \item 在不超过 $x$ 的正整数中，以 $b$ 为基数的伪素数比素数要少得多
        \item 小于 $10^{10}$ 的正整数中，有 455052512 个素数，只有 14884 个以 2 为基数的伪素数
        \item 选择更多的基数 $b_1, b_2, \cdots, b_k$ 进行类似的测试，通过所有测试的整数，要么是素数，要么是以所有 $b_1, b_2, \cdots, b_k$ 为基数的伪素数
    \end{itemize}

    \textbf{卡米切尔数（Carmichael Number）}
    \begin{itemize}
        \item 一个正合数 $n$，如果对于所有满足 $\gcd(b, n) = 1$ 的正整数 $b$ 都有同余式 $b^{n-1} \equiv 1 \pmod{n}$ 成立，则称为卡米切尔数
        \item 例如：$561 = 3 \times 11 \times 17$
        \item 如果 $\gcd(b, 561) = 1$，则 $\gcd(b, 3) = 1$，$\gcd(b, 11) = 1$，$\gcd(b, 17) = 1$
        \item 由费马小定理，$b^2 \equiv 1 \pmod{3}$，$b^{10} \equiv 1 \pmod{11}$，$b^{16} \equiv 1 \pmod{17}$
        \item 因为 $560 = 2 \cdot 280 = 10 \cdot 56 = 16 \cdot 35$
        \item 所以 $b^{560} \equiv 1 \pmod{561}$
    \end{itemize}

    \textbf{米勒测试（Miller’s Test）}
    \begin{itemize}
        \item 设 $n$ 为一个正奇数，令 $n - 1 = 2^s t$，其中 $s$ 为正整数，$t$ 为正奇数
        \item 对于 $b \in \mathbb{Z}^+$，$\gcd(b, n) = 1$，如果
        \[
            \left(b^t \equiv 1 \pmod{n}\right) \vee \left(\exists i \left(0 \leq i < s\right) \wedge \left(b^{2^i t} \equiv -1 \pmod{n}\right)\right)
        \]
        \item 则称 $n$ 通过了以 $b$ 为基数的米勒测试
        \item 一个合数 $n$ 能通过的米勒测试基数（$1 < b < n$）的个数少于 $n/4$
    \end{itemize}

    \textbf{强伪素数（Strong Pseudoprime）}
    \begin{itemize}
        \item 通过了以 $b$ 为基数的米勒测试的合数，称为以 $b$ 为基数的强伪素数
    \end{itemize}

    \textbf{例：}
    \begin{itemize}
        \item 561, $560 = 2^4 \cdot 35$
        \[
        2^{35} \equiv 263 \pmod{561}
        \]
        \[
        2^{2 \cdot 35} \equiv 263^2 \equiv 166 \pmod{561}
        \]
        \[
        2^{2^2 \cdot 35} \equiv 166^2 \equiv 67 \pmod{561}
        \]
        \[
        2^{2^3 \cdot 35} \equiv 67^2 \equiv 1 \pmod{561}
        \]
        \[
        2^{2^4 \cdot 35} \equiv 1^2 \equiv 1 \pmod{561}
        \]
        \item 所以 561 是以 2 为基数的伪素数，但不是以 2 为基数的强伪素数
    \end{itemize}

    \textbf{例：}
    \begin{itemize}
        \item 221, $220 = 2^2 \cdot 55$
        \[
        174^{55} \equiv 47 \pmod{221}
        \]
        \[
        174^{2 \cdot 55} \equiv 47^2 \equiv 220 \equiv -1 \pmod{221}
        \]
        \[
        174^{2^2 \cdot 55} \equiv 220^2 \equiv 1 \pmod{221}
        \]
        \item 所以 221 是以 174 为基数的强伪素数
    \end{itemize}

    \textbf{米勒-拉宾测试（Miller-Rabin Test）}
    \begin{itemize}
        \item 基于米勒测试的确定性算法的复杂度为 $O(n) = O(2^{\log n})$
        \item 米勒-拉宾测试通过随机选择 $k$ 个基数 $b$，算法复杂度为 $O(k \log^3 n)$
        \item 错误概率 $\leq 4^{-k}$
    \end{itemize}

    \textbf{计算复杂性}
    \begin{itemize}
        \item 很长时间以来，素数判定问题有多项式时间随机算法（BPP复杂性类），但是一直没有发现多项式时间的确定性算法（无条件）
        \item 2002年，印度科学家Manindra Agrawal和他的学生Neeraj Kayal, Nitin Saxena发现了一个确定性的多项式时间算法（2006年获Fulkerson奖和Gödel奖）
    \end{itemize}
\end{definition}

\subsection{原根和离散对数}

\begin{definition}
    \textbf{原根（Primitive Root）}
    \begin{itemize}
        \item 模素数 $p$ 的一个原根是 $\mathbb{Z}_p$ 中的整数 $r$，使得 $\mathbb{Z}_p$ 中的每一个非零元素都是 $r$ 的一个幂次
    \end{itemize}

    \textbf{示例：}
    \begin{itemize}
        \item 在 $\mathbb{Z}_{11}$ 中计算 2 的幂次：
        \[
        \begin{aligned}
            &2^1 = 2, \\
            &2^2 = 4, \\
            &2^3 = 8, \\
            &2^4 = 5, \\
            &2^5 = 10, \\
            &2^6 = 9, \\
            &2^7 = 7, \\
            &2^8 = 3, \\
            &2^9 = 6, \\
            &2^{10} = 1
        \end{aligned}
        \]
        \item 所以 2 是 11 的原根
        \item 在 $\mathbb{Z}_{11}$ 中计算 3 的幂次：
        \[
        \begin{aligned}
            &3^1 = 3, \\
            &3^2 = 9, \\
            &3^3 = 5, \\
            &3^4 = 4, \\
            &3^5 = 1
        \end{aligned}
        \]
        \item 所以 3 不是 11 的原根
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\textwidth]{yuangen.png}
    \end{figure}

    \begin{itemize}
        \item 对于每个素数 $p$ 都存在一个模 $p$ 的原根
    \end{itemize}

    \textbf{离散对数（Discrete Logarithm）}
    \begin{itemize}
        \item 假设 $p$ 是一个素数，$r$ 是一个模 $p$ 的原根，而 $a$ 是一个整数 $1 \leq a \leq p - 1$
        \item 如果 $r^d \mod{p} = a $ 且 $0 \leq d \leq p - 1$，则说 $d$ 是以 $r$ 为底 $a$ 模 $p$ 的离散对数
        \item 记作 $\log_r a = d$（隐含模素数 $p$）
    \end{itemize}

    \textbf{示例：}
    \begin{itemize}
        \item $\log_2 3 = 8$，因为 $2^8 = 256 \equiv 3 \pmod{11}$
        \item $\log_2 5 = 4$，因为 $2^4 = 16 \equiv 5 \pmod{11}$
    \end{itemize}

    \textbf{离散对数问题}
    \begin{itemize}
        \item 给定一个素数 $p$，一个模 $p$ 的原根 $r$，和一个正整数 $a \in \mathbb{Z}_p$，求 $\log_r a$
        \item 目前为止，没有已知的多项式时间算法可以求解离散对数问题
        \item 离散对数问题的困难性使得它在密码学中起着重要作用
    \end{itemize}
\end{definition}



\section{同余的应用}

\subsection{散列函数}

\begin{definition}
    \textbf{散列函数（Hash Function）}
    \begin{itemize}
        \item 又称散列算法、哈希函数，一个广义的算法，是一种思想
        \item 散列函数 $h(k)$（散列值）将任意长度的输入数据 $k$（关键值）变换成固定长度的输出
        \item 输出空间的大小通常远小于输入空间，不同的输入可能会映射到相同的输出，称发生了碰撞（collision）
        \item 一个好的散列函数：
        \begin{itemize}
            \item 易于计算
            \item 碰撞概率小（散列值分布均匀）
            \item 满射
        \end{itemize}
    \end{itemize}

    \textbf{应用：哈希表}
    \begin{itemize}
        \item 将记录保存到一个大小为 $m$ 的数据表中，如何才能快速检索到特定的记录？
        \item 利用散列函数 $h$ 将地址 $h(k)$ 分配给以 $k$ 为键值的记录
        \item 例如 $h(k) = k \mod m$
        \[
        \begin{aligned}
            &h(064212848) = 064212848 \mod 111 = 14 \\
            &h(037149212) = 037149212 \mod 111 = 65 \\
            &h(107405723) = 107405723 \mod 111 = 14
        \end{aligned}
        \]
        \item 冲突解决办法：
        \begin{itemize}
            \item 线性探测函数（linear probing function） $h(k, i) = (h(k) + i) \mod m$
            \item 即寻找第一个未被占用的地址
        \end{itemize}
    \end{itemize}
\end{definition}

\subsection{伪随机数的生成}

\begin{definition}
    \textbf{伪随机数（Pseudorandom Number）}
    \begin{itemize}
        \item 计算机中需要大量的随机数，其中大部分是使用计算方法生成的伪随机数
    \end{itemize}

    \textbf{线性同余生成器（Linear Congruential Generator，LCG）}
    \begin{itemize}
        \item 参数：模 $m$，倍数 $a$，增量 $c$，种子 $x_0$，其中 $2 \leq a < m$，$0 \leq c, x_0 < m$
        \item 计算公式：$x_{n+1} = (ax_n + c) \mod m$
        \item 令 $u_n = \frac{x_n}{m}$ 可得 0-1 之间的均匀分布随机数序列 $\left\{u_n\right\}$
        \item 如果 $c = 0$，又称为乘法同余生成器（Multiplicative Congruential Generator）
        \item 很长一段时间里是计算机中缺省的伪随机数生成器，由于不具有一些重要的统计性质，目前已经被梅森旋转法（Mersenne Twister）所取代
    \end{itemize}
\end{definition}

\subsection{校验码}

\begin{definition}
    \textbf{校验码（Check Digits）}
    \begin{itemize}
        \item 检查数字串是否有错误的一个常用办法是加上一个额外的校验位
        \item 校验码是由前面的数字串通过一个特定的函数计算得到
        \item 如果校验码不正确，说明前面的数字串有错误
    \end{itemize}

    \textbf{奇偶校验位}
    \begin{itemize}
        \item 计算机通信中会加入奇偶校验位，以检测传输过程中是否发生错误
        \[
        x_{n+1} = x_1 + x_2 + \cdots + x_n \mod 2
        \]
        \item 如果前 $n$ 个比特中有偶数个 1，则校验位为 0，否则校验位为 1
        \item 奇偶校验位可以检测到发生了奇数个错误，但不能检测到偶数个错误
    \end{itemize}

    \textbf{通用产品代码（Universal Product Code）}
    \begin{itemize}
        \item 用于零售产品标识
        \item 12 位十进制数字：1 位标识产品种类，2-6位标识制造商，7-11位标识特定产品，12位为校验码
        \item 校验码由以下同余式决定：
        \[
        3\sum_{i=1,3,5,7,9,11} x_i + \sum_{i=2,4,6,8,10,12} x_i \equiv 0 \pmod{10}
        \]
        \item 例如 79357343104 是一个有效的UPC，041331021641不是一个有效的UPC
    \end{itemize}

    \textbf{身份证校验码}
    \begin{itemize}
        \item 假设身份证号码前 17 位为 $a_1a_2 \cdots a_{17}$
        \item 计算 $c = (7a_1 + 9a_2 + 10a_3 + 5a_4 + 8a_5 + 4a_6 + 2a_7 + 1a_8 + 6a_9 + 3a_{10} + 7a_{11} + 9a_{12} + 10a_{13} + 5a_{14} + 8a_{15} + 4a_{16} + 2a_{17}) \mod 11$
        \item 根据 $c = 0,1,2, \cdots, 10$ 对应的第 18 位校验码为 1,0,X,9,8,7,6,5,4,3,2
        \item 等价的，$a_{18} + c \equiv 1 \pmod{11}$
    \end{itemize}

    \textbf{标识码检测的常见错误}
    \begin{itemize}
        \item 单错（single error）：标识码中一位数字发生错误
        \item 换位错（transposition error）：标识码中两位数字交换位置
    \end{itemize}
\end{definition}

\chapter{归纳与递归}

\section{数学归纳法}

\subsection{归纳法}
\begin{itemize}
    \item 归纳法：由一些特殊事例或全部可能情形，归纳出一般结论
    \begin{itemize}
        \item 完全归纳法：
        \begin{itemize}
            \item 全班成绩及格
        \end{itemize}
        \item 不完全归纳法：
        \begin{itemize}
            \item 天鹅都是白的
            \item 凸 $n$ 边形内角和为 $(n - 2) \cdot 180^\circ$
            \item 费马数是素数
            \item 归纳法不能严格保证结论的正确性
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{数学归纳法}
\begin{itemize}
    \item 数学归纳法原理
    \begin{itemize}
        \item 为证明对所有正整数 $n$，命题函数 $P(n)$ 都为真，需要完成两个步骤：
        \begin{itemize}
            \item 基础步骤：证明 $P(1)$ 为真
            \item 归纳步骤：证明对每个正整数 $k$ 来说，条件语句 $P(k) \rightarrow P(k+1)$ 为真
        \end{itemize}
        \item 为了完成归纳步骤，我们需要证明：
        \begin{itemize}
            \item 如果归纳假设（假定对于任意一个正整数 $k$，$P(k)$ 为真）成立，则 $P(k+1)$ 必定为真
        \end{itemize}
        \item 注意：
        \begin{itemize}
            \item 证明中并不假设对所有正整数 $P(k)$ 为真！否则就是循环论证
            \item 证明并不总是从整数 1 开始，基础步骤可能从某个整数 $b$ 开始
        \end{itemize}
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item 数学归纳法可以表示为如下的推理规则（论域为正整数集合）
    \[
    P(1) \wedge \forall k (P(k) \rightarrow P(k+1)) \rightarrow \forall n P(n)
    \]
    \item “数学归纳法”这一术语与常识“归纳”是冲突的
    \begin{itemize}
        \item 归纳：一种推理方法，由一系列具体的事实概括出一般的原理
        \item 演绎推理（deductive reasoning）使用推理规则从前提得到结论
        \item 归纳推理（inductive reasoning）获得证据支持（但不保证）的结论
        \item 数学证明，包括基于数学归纳法的论证，都属于演绎推理
    \end{itemize}
\end{itemize}

\subsection{数学归纳法的有效性}
\begin{itemize}
    \item 数学归纳法的有效性来源于正整数集合的良序性
    \begin{itemize}
        \item 正整数集合的每个非空子集都有一个最小元
    \end{itemize}
    \item 数学归纳法有效性证明
    \begin{itemize}
        \item 假定 $P(1)$ 为真，且对所有正整数 $k$ 都有命题 $P(k) \rightarrow P(k+1)$ 为真
        \item 归谬证明法，假设至少存在一个正整数 $n$ 使得 $P(n)$ 为假，则使 $P(n)$ 为假的正整数集合 $S$ 非空，根据良序性公理，$S$ 中必有一个最小元素，记为 $m$
        \item 因为 $P(1)$ 为真，所以 $m$ 不可能是 1，因为 $m$ 为正整数，所以 $m-1$ 为正整数，因为 $m-1 < m$ 所以 $m \notin S$，因此 $P(m-1)$ 为真
        \item 所以条件语句 $P(m-1) \rightarrow P(m)$ 为假，与假设矛盾
        \item 所以对所有正整数 $n$ 都有 $P(n)$ 为真
    \end{itemize}
\end{itemize}

\subsection{数学归纳法的证明的步骤}
\begin{itemize}
    \item 数学归纳法
    \begin{enumerate}
        \item 将命题表示为“$\forall n \geq b, P(n)$”的形式，$b$ 为一个固定的整数；
        \item 基础步骤：
        \begin{itemize}
            \item 证明较小的 $n$ 时，$P(n)$ 为真，例如 $n = b, b+1, \cdots, b+j$；
        \end{itemize}
        \item 归纳步骤：
        \begin{itemize}
            \item 明确列出归纳假设，即：对任意确定的一个 $k \geq b+j$，$P(k)$ 为真；
            \item 列出归纳假设下需要证明的命题，即：$P(k+1)$ 为真；
            \item 利用 $P(k)$ 证明 $P(k+1)$，即：证明如果 $P(k)$ 为真则 $P(k+1)$ 为真；（关键）
        \end{itemize}
        \item 得出结论：依据数学归纳法，$\forall n \geq b, P(n)$ 为真
    \end{enumerate}
\end{itemize}

\subsection{数学归纳法的优点和缺点}
\begin{itemize}
    \item 优点：
    \begin{itemize}
        \item 能用于证明已经构造好的猜想
        \item 明确清晰的证明步骤和结构，容易理解
    \end{itemize}
    \item 缺点：
    \begin{itemize}
        \item 不能用于发现新定理
        \item 不能提供定理正确性的启示
    \end{itemize}
\end{itemize}

\subsection{数学归纳法的例子}
\subsection{数学归纳法的例子}
\begin{itemize}
    \item 例10：设 $S$ 为 $n$ 个元素的有限集合，$n$ 为非负整数，则 $S$ 有 $2^n$ 个子集
    \begin{itemize}
        \item 令 $P(n)$ 表示命题“$n$ 个元素的有限集合有 $2^n$ 个子集”
        \item 基础步骤：$P(0)$ 为真，因为空集恰有 1 个子集，即其自身，而 $2^0 = 1$
        \item 归纳步骤：
        \begin{itemize}
            \item 归纳假设：对于任意一个非负整数 $k$，$P(k)$ 为真，即 $k$ 个元素的有限集合有 $2^k$ 个子集
            \item 令 $T$ 为 $k+1$ 个元素的集合，则 $T = S \cup \{a\}$，其中 $a \in T$，$S = T \setminus \{a\}$，则 $S$ 有 $k$ 个元素
            \item 对于 $S$ 的每个子集 $X$，都恰好对应于 $T$ 的两个子集：$X$ 和 $X \cup \{a\}$
            \item 根据归纳假设，$S$ 有 $2^k$ 个子集，所以 $T$ 有 $2 \cdot 2^k = 2^{k+1}$ 个子集
        \end{itemize}
        \item 所以对所有非负整数 $n$，$P(n)$ 为真，即 $n$ 个元素的有限集合有 $2^n$ 个子集
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item 例12：（3.1.5节例7最优日程问题）
    \begin{itemize}
        \item 有一组讲座需要安排日程，每个讲座有固定的开始时间和结束时间，如何在一个报告厅安排最多数量讲座，使得满足以下规则
        \begin{itemize}
            \item 一个讲座开始后就不能停止，直到讲座结束
            \item 不能有两个讲座同时进行
            \item 一个讲座结束时可以马上开始另一个讲座
        \end{itemize}
        \item 贪心准则
        \begin{itemize}
            \item 准则1：和已选讲座不冲突的讲座中，开始时间最早的
            \item 准则2：和已选讲座不冲突的讲座中，讲座时间最短的
            \item 准则3：和已选讲座不冲突的讲座中，结束时间最早的
        \end{itemize}
        \item 贪心算法
        \begin{itemize}
            \item 利用排序算法对讲座结束时间进行排序
            \item 依次检查每个讲座是否与已选讲座冲突，如不冲突则可以加入
                    \end{itemize}
                    \item 证明该贪心算法的最优性：可以安排最多的讲座
                    \begin{itemize}
                        \item 令 $P(n)$ 表示命题“如果贪心算法安排了 $n$ 个讲座，那么不可能安排更多的讲座”
                        \item 基础步骤：假设贪心算法只安排了 1 个讲座 $t_1$，那么根据贪心算法，有以下不等式成立 $\forall i \neq 1, s_i < e_1 \leq e_i$，即所有讲座在 $e_1$ 之前的时刻都要使用报告厅，所以同一时间最多只能安排 1 个讲座。即 $P(1)$ 为真。
                        \item 归纳步骤：
                        \begin{itemize}
                            \item 归纳假设：$P(k)$ 为真，即如果贪心算法安排了 $k$ 个讲座，那么不可能安排更多的讲座。
                            \item 假定贪心算法安排了 $k+1$ 个讲座，我们需要证明不可能安排多于 $k+1$ 个讲座，即 $P(k+1)$ 为真。
                            \item 很容易证明存在一个最多讲座的日程包含讲座 $t_1$。如果一个日程不包含讲座 $t_1$，那么我们可以将它的第一个讲座 $t_i$ 替换为 $t_1$，因为 $e_1 \leq e_i$，所以这个替换不会影响日程中后续的讲座，因此替换后日程的讲座数量不变。
                            \item 一旦我们确定了第一个讲座是 $t_1$，那么这个问题就归结为从 $e_1$ 时刻开始的一个子问题：从开始时间在 $e_1$ 时刻或之后的讲座中安排尽可能多的讲座。
                            \item 因为贪心算法在讲座 $t_1$ 之后挑选了 $k$ 个讲座，根据归纳假设，在 $e_1$ 时刻或之后不可能安排更多的讲座，即从 $e_1$ 时刻开始的子问题最优解为 $k$。
                            \item 所以不可能安排多于 $k+1$ 个讲座，即 $P(k+1)$ 为真。
                        \end{itemize}
                        \item 根据数学归纳法，该贪心算法安排了最多的讲座，是最优的。
                    \end{itemize}
                \end{itemize}
            \end{itemize}

            \begin{itemize}
            \item 例13：奇数个馅饼的战斗
            \begin{itemize}
                \item 有奇数个玩家站在院子里，任意两人之间的距离都不相同。每人有一个馅饼，攻击时每个人将馅饼抛向离他最近的人。
                \begin{itemize}
                    \item 证明：至少有一个人没有被馅饼攻击。
                    \item 令 $P(n)$ 表示命题“在 $2n+1$ 个玩家的游戏里，至少有一个人没有被馅饼攻击”
                    \item 基础步骤：$P(1)$ 为真。当 $n=1$ 时有 3 位玩家。在三个人中，假设距离最近的两个人是 A 和 B，第三个人是 C。因为任意两人之间的距离都不相同，所以 AC 的距离和 BC 的距离都大于 AB 的距离，因此 C 不会受到 A 和 B 的攻击。
                    \item 归纳步骤：
                    \begin{itemize}
                        \item 归纳假设：$P(k)$ 为真，即在 $2k+1$ 个玩家的游戏里，至少有一个人没有被馅饼攻击
                        \item 为了证明 $P(k+1)$ 为真，考虑有 $2k+1+1=2k+3$ 个玩家的游戏，其中任意两人之间的距离都不相同。
                        \item 假设距离最近的两个人是 A 和 B，则 A 和 B 必须互相攻击。考虑两种情形：
                        \item 有其他人向 A 或 B 攻击。那么 A 和 B 遭受了至少 3 个馅饼的攻击，另外还有 $2k$ 个馅饼攻击剩余的 $2k+1$ 个人，那么至少有一个人没有被馅饼攻击。
                        \item 没有其他人向 A 或 B 攻击。由于 A 和 B 也没有攻击其他人，那么只有剩余的 $2k+1$ 人之间互相攻击，根据归纳假设，其中至少有一个人没有被馅饼攻击。
                        \item 所以如果 $P(k)$ 为真，则 $P(k+1)$ 为真。
                    \end{itemize}
                    \item 所以奇数个玩家参加的游戏里，至少有一个人没有被馅饼攻击。
                \end{itemize}
            \end{itemize}
        \end{itemize}

        \subsection{错误的数学归纳法的例子}

        \textbf{例5：平面上的任何一组相互之间都不平行的直线，必相交于一个公共点}
        \begin{itemize}
            \item 设 $P(n)$ 为命题“平面上的任何 $n$ 条相互之间都不平行的直线必相交于一个公共点”，试图证明 $\forall n \geq 2, P(n)$ 为真。
            \item 基础步骤：命题 $P(2)$ 为真（根据平行线的定义）。
            \item 归纳步骤：
            \begin{itemize}
                \item 归纳假设：对正整数 $k$，$P(k)$ 为真，即平面上的任何 $k$ 条相互之间都不平行的直线必相交于一个公共点。
                \item 我们需要证明 $P(k+1)$ 为真，即平面上的任何 $k+1$ 条相互之间都不平行的直线必相交于一个公共点。
                \item 考虑 $k+1$ 条不同的直线，相互之间都不平行。根据归纳假设，前 $k$ 条直线必相交于一个公共点 $p_1$，后 $k$ 条直线也必相交于一个公共点 $p_2$。
                \item 如果 $p_1$ 和 $p_2$ 是不同的点，所有包含这两个点的直线（$k-1$ 条）必是同一条直线（因为两点确定一条直线）。这与假设中“这些直线是不同的直线”相矛盾。因此 $p_1$ 和 $p_2$ 必是同一个点。
                \item 所以这 $k+1$ 条直线相交于一个公共点 $p_1 = p_2$，即 $P(k+1)$ 为真。
                \item 所以当 $P(k)$ 为真时，$P(k+1)$ 也为真，这就完成了归纳步骤。
            \end{itemize}
            \item 所以 $\forall n \geq 2, P(n)$ 为真。
            \item 错误在哪里？
        \end{itemize}

        \section{强归纳法与良序性}

        \subsection{强归纳法}
        
        \begin{itemize}
            \item 强归纳法有时又称作数学归纳法第二原理（The Second Principle of Mathematical Induction），或完全归纳法（Complete Induction）
            \item 数学归纳法、强归纳法、良序性是等价的原理
            \begin{itemize}
                \item 任意一个原理的有效性，都可以用另外的两种原理之一来证明
                \item 有时，用强归纳法证明比用数学归纳法更容易
                \item 有时，用良序性公理证明比用两种形式的数学归纳法更容易
            \end{itemize}
        \end{itemize}
        
        \textbf{强归纳法（Strong Induction）}
        \begin{itemize}
            \item 为证明对所有正整数 $n$，命题函数 $P(n)$ 都为真，需要完成两个步骤：
            \begin{itemize}
                \item 基础步骤：证明 $P(1)$ 为真
                \item 归纳步骤：证明对每个正整数 $k$ 来说，条件语句 $P(1) \land P(2) \land \cdots \land P(k) \rightarrow P(k+1)$ 为真
            \end{itemize}
            \item 区别：归纳假设
            \begin{itemize}
                \item 数学归纳法：对于任意一个正整数 $k$，$P(k)$ 为真
                \item 强归纳法：对于任意一个正整数 $k$，$\forall j \leq k, P(j)$ 为真
            \end{itemize}
        \end{itemize}
        
        \textbf{例1：新无限梯子问题}
        \begin{itemize}
            \item 假设我们有一个无限高的梯子，如果我们知道
            \begin{enumerate}
                \item 我们能够到达第 1 个和第 2 个阶梯
                \item 我们从某个阶梯能够到达高出两阶的那个阶梯
            \end{enumerate}
            \item 是否可以得到结论：我们可以到达这个梯子上的每一个阶梯？
            \begin{itemize}
                \item 尝试用数学归纳法证明
                \item 尝试用强归纳法证明
            \end{itemize}
        \end{itemize}
        
        \subsection{强归纳法的例子}
        
        \textbf{强归纳法（一般形式）}
        \begin{itemize}
            \item 将命题表示为“$\forall n \geq b, P(n)$”的形式，$b$ 为一个固定的整数；
            \item 基础步骤：
            \begin{itemize}
                \item 证明较小的 $n$ 时，$P(n)$ 成立，例如 $n = b, b+1, \cdots, b+j$；
            \end{itemize}
            \item 归纳步骤：
            \begin{itemize}
                \item 明确列出归纳假设，即：对任意确定的一个 $k \geq b+j$，$P(b) \land P(b+1) \land \cdots \land P(k)$ 为真；
                \item 列出归纳假设下需要证明的命题，即：$P(k+1)$ 为真；
                \item 利用 $P(b) \land P(b+1) \land \cdots \land P(k)$ 证明 $P(k+1)$，即：证明如果 $P(b) \land P(b+1) \land \cdots \land P(k)$ 为真则 $P(k+1)$ 为真；（关键）
            \end{itemize}
            \item 得出结论，即：依据强归纳法，$\forall n \geq b, P(n)$ 为真
        \end{itemize}
        
        \textbf{例2：正整数的素因子分解（算术基本定理之一部分）}
        \begin{itemize}
            \item 若 $n$ 为大于 1 的整数，则 $n$ 可以写成素数的乘积
            \item 证明：
            \begin{itemize}
                \item 令 $P(n)$ 表示命题“$n$ 可以写成素数之积”
                \item 基础步骤：
                \begin{itemize}
                    \item $P(2)$ 为真，因为 2 可以写成素数之积，即其自身
                \end{itemize}
                \item 归纳步骤：
                \begin{itemize}
                    \item 归纳假设：对于所有满足 $2 \leq j \leq k$ 的正整数 $j$，$P(j)$ 为真，即大于等于 2 且不超过 $k$ 的正整数都可以写成素数之积的形式
                    \item 需要证明在归纳假设下，$P(k+1)$ 为真，即正整数 $k+1$ 可以写成素数之积
                \end{itemize}
                \item 考虑两种情形：
                \begin{enumerate}
                    \item 若 $k+1$ 为素数，则 $k+1$ 可以写成素数之积，即其自身，所以 $P(k+1)$ 为真；
                    \item 若 $k+1$ 为合数，则 $k+1$ 可以写为两个整数 $a$ 和 $b$ 的乘积，且 $2 \leq a, b < k+1$。因为 $2 \leq a, b \leq k$，所以根据归纳假设，整数 $a$ 和 $b$ 都可以写成素数之积的形式。因此 $k+1$ 可以写成素数之积，所以 $P(k+1)$ 为真。
                \end{enumerate}
            \end{itemize}
            \item 所以所有大于 1 的整数都可以写成素数的乘积
        \end{itemize}
        
        \textbf{例3：火柴游戏}
        \begin{itemize}
            \item 考虑一个游戏，两个玩家轮流从两堆火柴中的一堆取出任意正整数根火柴，取走最后一根火柴的玩家获胜。证明：如果开始时两堆火柴的数目相同，则第二个玩家总是可以保证获胜。
            \item 证明：
            \begin{itemize}
                \item 设 $n$ 为正整数，令 $P(n)$ 表示命题“开始时每堆有 $n$ 根火柴，第二个玩家可以获胜”
                \item 基础步骤：
                \begin{itemize}
                    \item $P(1)$ 为真。当每堆只有 1 根火柴时，第一个玩家只有一种选择，从某一堆中取走 1 根火柴，剩下的一堆只有 1 根火柴，第二个玩家可以取走这根火柴而获胜。
                \end{itemize}
                \item 归纳步骤：
                \begin{itemize}
                    \item 归纳假设：对于所有满足 $1 \leq j \leq k$ 的整数 $j$，$P(j)$ 为真，即开始时每堆有 $j$ 根火柴，$1 \leq j \leq k$，则第二个玩家可以获胜
                    \item 需要证明在归纳假设下，$P(k+1)$ 为真，即开始时每堆有 $k+1$ 根火柴，第二个玩家可以获胜
                    \item 假设游戏开始时每堆都有 $k+1$ 根火柴，考虑两种情形：
                    \begin{enumerate}
                        \item 第一个玩家从其中一堆拿走了 $r$ 根火柴，$1 \leq r \leq k$，此时第二个玩家从另一堆中也取走了 $r$ 根火柴，那么每堆都剩下 $k+1-r$ 根火柴。因为 $1 \leq k+1-r \leq k$，所以根据归纳假设，第二个玩家可以获胜。
                        \item 第一个玩家从其中一堆拿走了 $k+1$ 根火柴，此时第二个玩家从另一堆中也取走 $k+1$ 根火柴，第二个玩家获胜。
                    \end{enumerate}
                \end{itemize}
            \end{itemize}
            \item 所以如果开始时两堆火柴的数目相同，则第二个玩家总是可以保证获胜
        \end{itemize}
        
        \textbf{例4：}
        \begin{itemize}
            \item 仅用 4 分和 5 分的邮票可以组成大于或等于 12 分的每种邮资
            \item 证明：
            \begin{itemize}
                \item 尝试用数学归纳法证明
                \item 尝试用强归纳法证明
            \end{itemize}
        \end{itemize}
        
        \subsection{良序性公理}
        
        \begin{itemize}
            \item 良序性公理（Well-Ordering Property）
            \begin{itemize}
                \item 正整数集合的每个非空子集都有一个最小元
            \end{itemize}
            \item 良序性（推广）
            \begin{itemize}
                \item 如果一个集合的每个非空子集都有最小元素，则称这个集合为良序的
                \item 自然数集合 $\mathbb{N}$ 是良序的（$\leq$）
                \item 定义在一个字母表上的有限字符串集合是良序的（字典序）
                \item 整数集合？
            \end{itemize}
            \item 数学归纳法、强归纳法、良序性是等价的原理
            \begin{itemize}
                \item 任意一个原理的有效性，都可以用另外的两种原理之一来证明
                \item 良序性公理 $\Rightarrow$ 数学归纳法：数学归纳法的有效性
                \item 数学归纳法 $\Rightarrow$ 良序性公理：用数学归纳法证明良序性公理
                \begin{itemize}
                    \item 用归谬证明法。假设良序性公理不成立，即：存在一个非空的正整数集合 $S$ 没有最小元素。
                    \item 令 $P(n)$ 表示命题“所有不超过 $n$ 的正整数都不属于 $S$”，即 $S \cap \{i \in \mathbb{Z}^+ \mid i \leq n\} = \emptyset$
                    \item 基础步骤：
                    \begin{itemize}
                        \item $P(1)$ 为真。因为如果 $1 \in S$ 则 1 为 $S$ 的最小元素，与假设 $S$ 没有最小元素矛盾。
                    \end{itemize}
                    \item 归纳步骤：
                    \begin{itemize}
                        \item 归纳假设：对于任意一个正整数 $k$，$P(k)$ 为真，即 $S \cap \{i \in \mathbb{Z}^+ \mid i \leq k\} = \emptyset$。
                        \item 需要证明当 $P(k)$ 为真时，$P(k+1)$ 为真。
                        \item 因为 $P(k)$ 为真，即 $S \cap \{i \in \mathbb{Z}^+ \mid i \leq k\} = \emptyset$，此时必然有 $k+1 \notin S$，否则 $k+1$ 为 $S$ 的最小元素，与假设 $S$ 没有最小元素矛盾。所以 $P(k+1)$ 为真。
                    \end{itemize}
                    \item 根据数学归纳法，对于所有正整数 $n$ 都有 $P(n)$ 为真，即所有不超过 $n$ 的正整数都不属于 $S$。
                    \item 所以正整数集合 $S$ 为空集，与假设 $S$ 非空矛盾。
                \end{itemize}
            \end{itemize}
        \end{itemize}
        
        \textbf{例5：用良序性公理证明整除算法（4.1.3节）}
        \begin{itemize}
            \item 若 $a$ 是整数且 $d$ 是正整数，则存在唯一的整数 $q$ 和 $r$ 满足 $0 \leq r < d$ 和 $a = dq + r$
            \item 证明：
            \begin{itemize}
                \item 设 $S$ 是形如 $a - dq$ 的非负整数的集合，其中 $q$ 是整数。
                \item 因为 $q$ 可以取任意的负整数，所以 $S$ 非空。
                \item 根据良序性公理，$S$ 有最小元素 $r = a - dq_0$
                \item 整数 $r$ 非负且 $r < d$，否则 $r - d \in S$，与 $r$ 为 $S$ 的最小元素矛盾。
                \item 假设 $r$ 不唯一，即 $a = dq + r = dq' + r'$，则 $d(q - q') = r - r'$，但是由 $0 \leq r, r' < d$ 可得 $-d < r - r' < d$，所以 $r - r' = q - q' = 0$
            \end{itemize}
        \end{itemize}
        
        \textbf{例6：}
        \begin{itemize}
            \item 在循环赛中，每两个选手恰好比赛一次，且每次比赛分出胜负。如果选手 $p_1$ 战胜 $p_2$，$p_2$ 战胜 $p_3$，$\cdots$，$p_{m-1}$ 战胜 $p_m$，$p_m$ 战胜 $p_1$，则称选手 $p_1, p_2, \cdots, p_m$ 形成回路。
            \item 用良序性公理证明，如果在参赛选手中存在长度为 $m \geq 3$ 的回路，则必定存在这些选手中三个选手的回路。
            \item 证明：
            \begin{itemize}
                \item 令 $S = \{n \in \mathbb{Z}^+ \mid \text{存在长度为 n 的回路，且 }n \geq 3\}$，根据条件 $S$ 非空。
                \item 根据良序性公理，$S$ 有最小元素，设为 $k$，对应回路为 $p_1, p_2, \cdots, p_k$。
                \item 假设不存在三个选手的回路，则 $k > 3$。
                \item 考虑这个回路的前三个选手 $p_1, p_2, p_3$。由回路知道 $p_1$ 战胜 $p_2$，$p_2$ 战胜 $p_3$。
                \item 如果 $p_3$ 战胜 $p_1$ 则 $p_1, p_2, p_3$ 形成三个选手的回路，矛盾。
                \item 如果 $p_1$ 战胜 $p_3$ 则 $p_1, p_3, \cdots, p_k$ 形成一个长度为 $k-1$ 的回路，因为 $k > 3$ 所以 $k-1 \in S$，这与 $k$ 是 $S$ 最小元素矛盾。
                \item 所以必定存在长度为 3 的回路。
            \end{itemize}
        \end{itemize}
        
\section{递归定义与结构归纳法}

\subsection{递归}
\textbullet\ 递归（Recursion）\\
一个对象部分地包含它自己，或用这个对象来给定义它自身，这个过程称为递归。递归有两种：
\begin{enumerate}
    \item 直接递归：自己包含自己
    \item 间接递归：A 包含 B ，B 包含 A
\end{enumerate}
\textbullet\ 递归可以用来定义序列、函数、集合与结构\\
\textbullet\ 序列：
\begin{itemize}
    \item 显式公式： $a_n = 2^n, n = 0,1,2, \ldots$
    \item 递归公式： $a_n = 2a_{n-1}, n = 1,2, \ldots , a_0 = 1$
    \item 可以用数学归纳法证明递归公式定义和显式公式等价
\end{itemize}

\subsection{递归定义函数}
\textbullet\ 递归定义（Recursive Definition），归纳定义（Inductive Definition）\\
定义自然数集合上的函数：
\begin{itemize}
    \item 序列 $a_0, a_1, a_2, \ldots , f(n) = a$
    \item 基础步骤：规定这个函数在 0 处的值
    \item 递归步骤：给出从较小的整数处的值来求出当前的值的规则
    \item 示例：
    \begin{itemize}
        \item $f(0) = 3, f(n + 1) = 2f(n) + 3, n \geq 0$
        \item 阶乘函数 $F(n) = n!$ 的递归定义：$F(0) = 1, F(n) = n \cdot F(n - 1) , n > 0$
        \item 指数函数 $f(n) = a^n$ 的递归定义：$f(0) = 1, f(n) = a \cdot f(n - 1) , n > 0$
    \end{itemize}
\end{itemize}

\textbullet\ 利用函数的递归定义证明或解题\\
例4：Fibonacci 序列
\begin{itemize}
    \item $\{F_n\}$ ：$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}, n \geq 2$
    \item 利用强归纳法证明：
    \begin{itemize}
        \item 对任意 $n \geq 3, n \in \mathbb{N}$， $F_n > \alpha^{n-2}$， 其中 $\alpha = \frac{1 + \sqrt{5}}{2}$
        \item 对任意 $n \in \mathbb{N}$， $F_n = \frac{\alpha^n - \beta^n}{\alpha - \beta}$ ，其中 $\alpha = \frac{1 + \sqrt{5}}{2}$ , $\beta = \frac{1 - \sqrt{5}}{2}$
    \end{itemize}
    \item 因为 $\alpha$ 和 $\beta$ 是方程 $ x^2 - x - 1 = 0$ 的根，所以对于 $ x = \alpha, \beta$ 都有 $x^2 = x + 1$
    \item 因此
    \[
    x^k = x^2 \cdot x^{k-2} = (x+1)x^{k-2} = x^{k-1} + x^{k-2},\quad x = \alpha, \beta
    \]
    \item 归纳步骤证明如下
    \[
    F_{k+1} = F_k + F_{k-1} > \alpha_{k-2} + \alpha_{k-3} = \alpha_{k-1}
    \]
    \[
    F_{k+1} = F_k + F_{k-1} = \frac{\alpha^k - \beta^k}{\alpha - \beta} + \frac{\alpha^{k-1} - \beta^{k-1}}{\alpha - \beta} = \frac{\alpha^{k+1} - \beta^{k+1}}{\alpha - \beta}
    \]
    \item 基础步骤？
\end{itemize}

\textbullet\ 拉梅定理（Lamé’s Theorem）\par
（欧几里得算法的计算复杂度）设 $a, b \in \mathbb{Z}^+$, $a \geq b$，则欧几里得算法求 gcd$(a, b)$ 需要的除法次数小于或等于 $b$ 的十进制位数的 5 倍
\begin{itemize}
    \item 证明：
    \begin{itemize}
        \item 假设欧几里得算法使用了 $n$ 次除法（$r_0 = a, r_1 = b$）：
        \[
        r_0 = q_1r_1 + r_2, 0 \leq r_2 < r_1
        \]
        \[
        r_1 = q_2r_2 + r_3, 0 \leq r_3 < r_2
        \]
        \[
        \vdots
        \]
        \[
        r_{n-2} = q_{n-1}r_{n-1} + r_n, 0 \leq r_n < r_{n-1}
        \]
        \[
        r_{n-1} = q_nr_n
        \]
        \item 因为商 $q_1, q_2, \ldots , q_{n-1} \geq 1, q_n \geq 2$ ，所以
        \[
        r_0 \geq 1 = f_2
        \]
        \[
        r_{n-1} \geq 2r_n \geq 2f_2 = f_3
        \]
        \[
        r_{n-2} \geq r_{n-1} + r_n \geq f_3 + f_2 = f_4
        \]
        \[
        \vdots
        \]
        \[
        r_2 \geq r_3 + r_4 \geq f_{n-1} + f_{n-2} = f_n
        \]
        \[
        b = r_1 \geq r_2 + r_3 \geq f_n + f_{n-1} = f_{n+1}
        \]
        \item 由例4的不等式 $f_{n+1} > \alpha_{n-1}$ 所以 $b > \alpha_{n-1}$
        \item 两侧取对数得 $\log_{10} b > (n - 1) \log_{10} \alpha > \frac{n - 1}{5}$
        \item 所以 $n \leq 5(\lfloor \log_{10} b \rfloor + 1)$
    \end{itemize}
\end{itemize}

\subsection{递归定义集合和结构}
\textbullet\ 类似的，递归定义集合也包含两个部分：
\begin{itemize}
    \item 基础步骤：指定集合的一些初始元素
    \item 递归步骤：给出从集合的已有元素来构造新元素的规则
    \item 排除规则（exclusion rule）：集合仅仅包含（一次或者多次应用）上述步骤生成的元素，一般默认成立而不显示指出
    \item 递归定义集合的结果，可以用结构归纳法来证明
\end{itemize}

\textbullet\ 例5：
\begin{itemize}
    \item 整数集合的子集 $S$
    \begin{itemize}
        \item $3 \in S$
        \item 若 $a \in S$ 且 $b \in S$ 则 $a + b \in S$
    \end{itemize}
    \item 自然数集合 $\mathbb{N}$
    \begin{itemize}
        \item $0 \in \mathbb{N}$
        \item 若 $n \in \mathbb{N}$ 则 $n + 1 \in \mathbb{N}$
    \end{itemize}
\end{itemize}

\textbullet\ 例6：
\begin{itemize}
    \item 字母表 $\Sigma$ 上的字符串集合 $\Sigma^*$
    \begin{itemize}
        \item $\epsilon \in \Sigma^*$ （$\epsilon$为不包含任何字符的空串）
        \item 若 $w \in \Sigma^*$ 且 $a \in \Sigma$ 则 $wa \in \Sigma^*$
    \end{itemize}
    \item 比特串：$\Sigma = \{0,1\}$
    \begin{enumerate}
        \item $\Sigma^* = \{\epsilon\}$
        \item $\Sigma^* = \{\epsilon, 0, 1\}$
        \item $\Sigma^* = \{\epsilon, 0, 1, 00, 01, 10, 11\}$
        \item $\ldots$
        \item $\Sigma^* = \{\epsilon, 0, 1, 00, 01, 10, 11, \ldots\}$
    \end{enumerate}
\end{itemize}

\textbullet\ 递归定义集合上的运算和函数
\begin{itemize}
    \item 字符串的长度（$\Sigma^*$ 上的函数 $l$）
    \begin{itemize}
        \item $l(\epsilon) = 0$
        \item $l(wa) = l(w) + 1$ ，若 $w \in \Sigma^*$, $a \in \Sigma$
    \end{itemize}
    \item 字符串连接运算（ $\Sigma^*$ 上的二元运算 $\cdot$）
    \begin{itemize}
        \item 若 $w \in \Sigma^*$ 则 $w \cdot \epsilon = w$
        \item 若 $w_1, w_2 \in \Sigma^*$ 且 $a \in \Sigma$ ，则 $w_1 \cdot (w_2a) = (w_1 \cdot w_2)a$
    \end{itemize}
\end{itemize}

\textbullet\ 递归定义各种类型的合成公式
\begin{itemize}
    \item 例8：
    \begin{itemize}
        \item 复合命题的合成公式
        \begin{itemize}
            \item $T, F$ 和 $s$ 都是合成公式，其中 $s$ 是命题变量
            \item 若 $p$ 和 $q$ 是合成公式，则 $\neg p , p \land q , p \lor q , p \rightarrow q , p \leftrightarrow q$ 都是合成公式
        \end{itemize}
        \item 重复应用递归定义，可知
        \begin{itemize}
            \item 合成公式： $p \lor q , r \land T , (p \lor q) \rightarrow (r \land q)$
            \item 非合成公式： $p \land \neg p, pq \land, \neg \land pq$
        \end{itemize}
    \end{itemize}
    \item 例9：
    \begin{itemize}
        \item 算术运算的合成公式
        \begin{itemize}
            \item 若 $x$ 是数字或变量，则 $x$ 是合成公式
            \item 若 $f$ 和 $g$ 是合成公式，则 $f + g , f - g , f \times g , f \div g, f \uparrow g$ 都是合成公式
        \end{itemize}
        \item 合成公式
        \begin{itemize}
            \item $x, y, 0, 3, x + 3 , x - 3 , x \times 3 , x \div 3 , x \uparrow 3$
            \item $((x + 3) + 3) , (x - (3 \times y))$
        \end{itemize}
        \item 非合成公式
        \begin{itemize}
            \item $x3+, y \times +x, \times x/y$
        \end{itemize}
    \end{itemize}
\end{itemize}

\textbullet\ 递归定义结构：树和图
\begin{itemize}
    \item 有根树
    \begin{itemize}
        \item 单个顶点 $r$ 是有根树
        \item 假设 $T_1, T_2, \ldots , T_n$ 是不相交的有根树，分别以 $r_1, r_2, \ldots , r_n$ 为根 ，则如下形成的图也是有根树：从根 $r$ 开始（$r$ 不在树 $T_1, T_2, \ldots , T_n$ 中），从 $r$ 到每个顶点 $r_1, r_2, \ldots , r_n$ 都加上一条边。
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{tree1.png}
    \end{figure}
    \item 扩展二叉树
    \begin{itemize}
        \item 空集是扩展二叉树
        \item 如果 $T_1, T_2$ 是扩展二叉树，则存在一个表示为 $T_1 \cdot T_2$ 的扩展二叉树，它包含根 $r$ 、左子树 $T_1$、右子树 $T_2$，以及从 $r$ 到非空子树 $T_i$ 的根的边
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{tree2.png}
    \end{figure}
    \item 满二叉树
    \begin{itemize}
        \item 单个顶点是满二叉树
        \item 如果 $T_1, T_2$ 是满二叉树，则存在一个表示为 $T_1 \cdot T_2$ 的满二叉树，它包含根 $r$ 、左子树 $T_1$、右子树 $T_2$，以及从 $r$ 到子树 $T_i$ 的根的边
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{tree3.png}
    \end{figure}
\end{itemize}

\subsection{结构归纳法}
\textbullet\ 结构归纳法（Structural Induction）
\begin{itemize}
    \item 证明一个递归定义集合的所有元素都具有的性质
    \item 基础步骤：
    \begin{itemize}
        \item 针对集合递归定义中的基础步骤，证明：对于每个初始元素，命题成立
    \end{itemize}
    \item 递归步骤：
    \begin{itemize}
        \item 针对集合递归定义中生成新元素的规则，证明：如果命题对于构造新元素时使用的每个元素都成立，则命题对于构造出来的新元素也成立
    \end{itemize}
    \item 有效性来自数学归纳法原理
    \item 命题 $P(n)$ 表示“应用递归定义的递归步骤不超过 $n$ 次所生成的元素，断言为真”
\end{itemize}

\textbullet\ 例10：
\begin{itemize}
    \item 例5定义的集合 $S$ 是所有被 3 整除的正整数集合
    \begin{itemize}
        \item $3 \in S$
        \item 若 $a \in S$ 且 $b \in S$ ，则 $a + b \in S$
    \end{itemize}
    \item 证明：
    \begin{itemize}
        \item 设 $A$ 为被 3 整除的所有正整数的集合
        \item 为了证明 $S = A$ ，我们需证明 $A \subseteq S$ 且 $S \subseteq A$
    \end{itemize}
    \item 证 $A \subseteq S$ ：
    \begin{itemize}
        \item 令命题 $P(n)$ 表示“$3n \in S$”，用数学归纳法。
        \item 根据集合的递归定义，$3 \in S$ ，即 $P(1)$ 为真。
        \item 若 $P(k)$ 为真，即 $3k \in S$ ，则 $3(k + 1) = 3k + 3$ ，根据集合的递归定义，$3k + 3 \in S$ ，即 $P(k + 1)$ 为真。
    \end{itemize}
    \item 证 $S \subseteq A$ （结构归纳法）：
    \begin{itemize}
        \item 集合递归定义基础步骤定义： $3 \in S$ 。而 $3|3$ ，所以 $3 \in A$ 。
        \item 集合递归定义递归步骤定义：若 $x \in S$ 且 $y \in S$ 则 $x+y \in S$ 。根据整除性的性质，若$3|x$ 且 $3|y$ 则 $3|(x+y)$ ，所以若$x \in A$ 且 $y \in A$ 则 $x+y \in A$ 。
    \end{itemize}
\end{itemize}

\textbullet\ 例12
\begin{itemize}
    \item 证明 $l(xy) = l(x) + l(y)$ , $x, y \in \Sigma^*$
    \begin{itemize}
        \item 证明：
        \begin{itemize}
            \item 令 $P(\omega)$ 表示命题“$\forall x \in \Sigma^*, l(x\omega) = l(x) + l(\omega)$”
            \item 基础步骤：
            \begin{itemize}
                \item 因为 $\forall x \in \Sigma^*, l(x\lambda) = l(x) = l(x) + 0 = l(x) + l(\lambda)$ ，所以 $P(\lambda)$ 为真。
            \end{itemize}
            \item 递归步骤：
            \begin{itemize}
                \item 假定 $P(y)$ 为真，即 $\forall x \in \Sigma^*, l(xy) = l(x) + l(y)$ 。因为 $\forall a \in \Sigma, \forall x \in \Sigma^*, l(xya) = l(xy) + 1 = l(x) + l(y) + 1 = l(x) + l(ya),$ ，即 $P(ya)$ 为真。
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}

\textbullet\ 满二叉树的高度
\begin{itemize}
    \item 只含有树根 $r$ 的满二叉树 $T$ 的高度是 $h(T) = 0$
    \item 若 $T_1, T_2$ 为满二叉树，则满二叉树 $T = T_1 \cdot T_2$ 的高度是 $h(T) = 1 + \max(h(T_1), h(T_2))$
\end{itemize}

\textbullet\ 满二叉树的顶点数
\begin{itemize}
    \item 只含有树根 $r$ 的满二叉树 $T$ 的顶点数是 $n(T) = 1$
    \item 若 $T_1, T_2$ 为满二叉树，则满二叉树 $T = T_1 \cdot T_2$ 的顶点数是 $n(T) = 1 + n(T_1) + n(T_2)$
\end{itemize}

\textbullet\ 定理2（满二叉树顶点数估计）
\begin{itemize}
    \item 如果 $T$ 是满二叉树，则 $n(T) \leq 2^{h(T) + 1} - 1$
    \item 证明：
    \begin{itemize}
        \item 用结构归纳法证明。
        \item 基础步骤：
        \begin{itemize}
            \item 对于只含有树根 $r$ 的满二叉树，因为 $n(T) = 1, h(T) = 0$ ，所以 $n(T) \leq 2^{0+1} - 1 = 1$ ，结论成立。
        \end{itemize}
        \item 递归步骤：
        \begin{itemize}
            \item 假设当 $T_1, T_2$ 都是满二叉树时， $n(T_1) \leq 2^{h(T_1) + 1} - 1, n(T_2) \leq 2^{h(T_2) + 1} - 1$
            \item 根据递归公式，$n(T) = 1 + n(T_1) + n(T_2)$ , $h(T) = 1 + \max(h(T_1), h(T_2))$
            \item $n(T) = 1 + n(T_1) + n(T_2) \leq 1 + 2^{h(T_1) + 1} - 1 + 2^{h(T_2) + 1} - 1 \leq 2 \cdot \max(2^{h(T_1) + 1}, 2^{h(T_2) + 1}) - 1 = 2 \cdot 2^{h(T)} - 1 = 2^{h(T) + 1} - 1$
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{广义归纳法}

\textbullet\ 广义归纳法（Generalized Induction）
\begin{itemize}
    \item 将数学归纳法从整数推广到所有具有良序性的集合
\end{itemize}

\textbullet\ 例13（非负整数上的有序对）
\begin{itemize}
    \item $\mathbb{N} \times \mathbb{N}$ 上的字典序
    \begin{itemize}
        \item $(a_1, b_1), (a_2, b_2) \in \mathbb{N} \times \mathbb{N}$
        \item 如果 $a_1 < a_2$ 则 $(a_1, b_1) \leq (a_2, b_2)$
        \item 如果 $a_1 = a_2, b_1 < b_2$ 则 $(a_1, b_1) \leq (a_2, b_2)$
    \end{itemize}
    \item $\mathbb{N} \times \mathbb{N}$ 是良序的
\end{itemize}

\textbullet\ 假设 $m, n \in \mathbb{N} \times \mathbb{N}$ ，递归定义
\begin{itemize}
    \item $a_{0,0} = 0$
    \item $a_{m,n} = \begin{cases} 
        a_{m-1,n} + 1 & \text{if } n = 0 ,m > 0 \\
        a_{m,n-1} + n & \text{if } n > 0 
    \end{cases}$
\end{itemize}

\textbullet\ 证明 $a_{m,n} = m + \frac{n(m + 1)}{2}$
\begin{itemize}
    \item 基础步骤：$a_{0,0} = 0 + \frac{0 \cdot 1}{2}$
    \item 递归步骤：
    \begin{itemize}
        \item 假设 $\forall (s,t) \leq (m, n)$ , $a_{s,t} = s + \frac{t(t + 1)}{2}$
        \item 若 $n = 0$ ，$a_{m,n} = a_{m-1,n} + 1 = m - 1 +\frac{n(n+1)}{2} + 1 = m + \frac{n(n + 1)}{2}$
        \item 若 $n > 0$ ，$a_{m,n} = a_{m,n-1} + n = m + \frac{(n-1)n}{2} + n = m + \frac{n(n + 1)}{2}$
    \end{itemize}
\end{itemize}

\section{递归算法}

\subsection{递归算法}

\textbullet\ 递归算法（Recursive Algorithm）
\begin{itemize}
    \item 若一个算法通过把问题规约到更小输入规模的相同问题实例来解决原问题，则这个算法称为递归的。
    \item 算法通过直接或间接地调用自身，但每次调用的输入规模都能减小
    \begin{itemize}
        \item 把（不能求解或者不好求解的）“大问题”转化为一个或者几个“小问题”
        \item “大问题”和“小问题”是相同问题的不同规模实例
        \item 把“小问题”进一步转化为一个或者几个更小的“小问题”
        \item 直至“小问题”可以（很容易地）直接求解
    \end{itemize}
    \item 一种有效的分析问题和算法设计方法，解决很多复杂问题的重要方法
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui1.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui2.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui3.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui4.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui5.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui6.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{digui7.png}
\end{figure}

\subsection{递归算法的正确性}

\textbullet\ 递归算法与数学归纳法
\begin{itemize}
    \item 数学归纳法是一种证明方法
    \item 递归算法是一种算法设计方法
    \item 数学归纳法是递归算法设计的基础
    \item 递归算法的正确性可以用数学归纳法证明
    \begin{itemize}
        \item 递归边界 $\leftrightarrow$ 基础步骤
        \item 递归体 $\leftrightarrow$ 归纳步骤
        \item 递归算法的分解过程 $\leftrightarrow$ 数学归纳法的分析过程
    \end{itemize}
\end{itemize}

\subsection{递归与迭代}

\textbullet\ 迭代算法（Iterative Algorithm）
\begin{itemize}
    \item 不使用递归算法的分解过程，而是直接从一个递归边界出发进行计算
    \item 通常用递归定义的迭代算法要比用递归算法减少很多计算量
    \item 但有时递归算法更容易实现（什么时候？）
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{diedai1.png}
\end{figure}

\subsection{归并排序}

\textbullet\ 归并排序（Merge Sort）
\begin{itemize}
    \item 一种递归排序算法
    \item 达到了最好可能的时间复杂度 $O(n \log n)$
    \item 将需要排序的列表分为两个等长（相差最多一个元素）的两个子表
    \item 对两个子表递归调用归并排序
    \item 将排完序的两个子表合并成一个列表
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{guibing1.png}
\end{figure}

\textbullet\ 引理1
\begin{itemize}
    \item 使用不超过 $m + n - 1$ 次比较，可以把 $m$ 个元素和 $n$ 个元素的两个有序列表合并成一个有序列表。
\end{itemize}

\textbullet\ 定理1
\begin{itemize}
    \item 对 $n$ 个元素的列表进行归并排序所需要的比较次数是 $O(n \log n)$。
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{guibing2.png}
\end{figure}


\chapter{计数}

组合数学
\textbullet\ 组合数学（Combinatorial Mathematics）
\begin{itemize}
    \item 计数问题属于组合数学的范畴
    \item 组合数学是离散数学的重要组成部分
    \item 广义的组合数学就是离散数学
    \item 狭义的组合数学
    \begin{itemize}
        \item 组合计数
        \item 组合设计
        \item 组合优化
        \item ⋯
    \end{itemize}
\end{itemize}

\textbullet\ 组合数学
\begin{itemize}
    \item 主要研究离散结构或对象的存在性、计数、构造和优化等问题的一门学科
    \item 中心问题：按照一定规则来安排有限多个对象
    \item 存在性问题：符合要求的方案存在吗？ （基本问题）
    \item 计数问题：符合要求的方案有多少种？ （列举或分类）
    \item 构造性问题：符合要求的方案都是什么？ （性质或结构）
    \item 优化问题：符合要求的方案哪个最好？ （最优化）
\end{itemize}

\section{计数基础}
\subsection{计数}
\textbullet\ 组合计数
\begin{itemize}
    \item 计数原则：加法/乘法原理
    \item 计数定理：容斥原理/Polya定理
    \item 计数方法：递推方程/生成函数
    \item 计数模型：不定方程求解/整数拆分…
\end{itemize}
\textbullet\ 组合存在
\begin{itemize}
    \item 鸽巢原理/Ramsey理论
\end{itemize}

\subsection{计数基本原则}
\textbullet\ 加法原理（Addition Principle）
\begin{itemize}
    \item 也称为：求和法则（The Sum Rule）
    \item 如果有两种途径完成一项任务，第一种有 $n_1$ 个方法，第二种有 $n_2$ 个方法，且两种途径的方法没有交集，则完成该任务共有 $n_1 + n_2$ 个方法。
    \item 推广：
    \begin{itemize}
        \item 如果有 $k$ 种途径完成一项任务，第 $i$ 种有 $n_i$ 个方法，且不同途径的方法没有交集，则完成该任务共有 $n_1 + n_2 + \cdots + n_k$ 个方法。
    \end{itemize}
\end{itemize}

\textbullet\ 加法原理是分类计数原理
\begin{itemize}
    \item 集合的视角：集合的划分
    \[
    |S| = |A_1 \cup A_2 \cup \cdots \cup A_m| = |A_1| + |A_2| + \cdots + |A_m|
    \]
    若 $A_1, A_2, \cdots , A_m$ 均是集合 $S$ 的子集，且同时满足
    \begin{itemize}
        \item $\forall i \neq j, A_i \cap A_j = \emptyset$
        \item $A_1 \cup A_2 \cup \cdots \cup A_m = S$
    \end{itemize}
    则称 $A_1, A_2, \cdots , A_m$ 是集合 $S$ 的一个划分
\end{itemize}

\textbullet\ 乘法原理（Multiplication Principle）
\begin{itemize}
    \item 也称为：乘积法则（The Product Rule）
    \item 如果一项任务可以被分解为相继的两个步骤，完成第一个步骤有 $n_1$ 个方法，完成第二个步骤有 $n_2$ 个方法，则完成这项任务共有 $n_1n_2$ 个方法。
    \item 推广：
    \begin{itemize}
        \item 如果一项任务可以被分解为相继的 $k$ 个步骤，完成第 $i$ 个步骤有 $n_i$ 个方法，则完成这项任务共有 $n_1n_2 \cdots n_k$ 个方法。
    \end{itemize}
\end{itemize}

\textbullet\ 乘法原理是分步计数原理
\begin{itemize}
    \item 集合的视角：每个步骤方法集合的笛卡尔积
    \[
    |S| = |A \times B| = |A| \times |B|
    \]
    \begin{itemize}
        \item 设第一步的方法集合为 $A$
        \item 第二步的方法集合为 $B$
        \item 则完成两步过程的方法可以表示为序偶 $(a, b)$ , $a \in A, b \in B$ 。
        \item 集合 $S = A \times B = \{(a, b) \mid a \in A, b \in B\}$ 称为集合 $A$ 与 $B$ 的笛卡尔积
    \end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu1.png}
\end{figure}

\subsection{比较复杂的计数问题}
\textbullet\ 例15
\begin{itemize}
    \item 在计算机BASIC语言的某个版本中，变量的名字是含有一个或两个字符的字符串，其中字符可以是 26 个英文字母或者 10 个数字，不区分大写和小写字母。此外变量名必须以字母开始，并且必须与由两个字符构成的 5 个保留字相区别。在这个版本的BASIC中，一共有多少个不同的变量名？
    \item 令 $V_i$ 表示长度为 $i$ 的变量名数量
    \[
    V_1 = 26
    \]
    \[
    V_2 = 26 \cdot 36 - 5 = 931
    \]
    \[
    V = V_1 + V_2 = 957
    \]
\end{itemize}

\textbullet\ 例16
\begin{itemize}
    \item 一个计算机系统的用户密码由 6-8 个字符构成，其中每个字符可以是大写字母或者数字，且每个密码必须至少包含一个数字。在这个系统中，有多少个可能的密码？
    \item 令 $P_i$ 表示长度为 $i$ 的密码数量
    \[
    P_6 = 36^6 - 26^6 = 1867866560
    \]
    \[
    P_7 = 36^7 - 26^7 = 70332353920
    \]
    \[
    P_8 = 36^8 - 26^8 = 2612282842880
    \]
    \[
    P = P_6 + P_7 + P_8 = 2684483063360
    \]
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu2.png}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{jishu3.png}
\end{figure}


\textbullet\ 例：
\begin{enumerate}
    \item 求能整除 360 的正整数的数目？
    \item 有多少各位数字非零且不同的两位数？
    \item 在 0 和 10000 之间有多少个整数恰好有一位数字是 5 ？
    \item 在 1000 和 9999 之间有多少个具有不同数字的奇数？
\end{enumerate}

\subsection{减法原理}
\textbullet\ 减法原理
\begin{itemize}
    \item 如果有两种途径完成一项任务，第一种有 $n_1$ 个方法，第二种有 $n_2$ 个方法，两种途径有 $c$ 个共同的方法，则完成该任务共有 $n_1 + n_2 - c$ 个方法。
    \item 集合的视角：容斥原理（两个集合的版本）
    \[
    |A_1| \cup |A_2| = |A_1| + |A_2| - |A_1 \cap A_2|
    \]
\end{itemize}

\textbullet\ 例18
\begin{itemize}
    \item 以 1 开始或者以 00 结束的 8 位比特串有多少个？
\end{itemize}

\textbullet\ 例19
\begin{itemize}
    \item 一个年级共有 350 名学生，选修《计算机原理》和《商务英语》两门课程的分别有 220 和 147 人，同时选修这两门课程的有 51 人，问两门课程都没有选的学生有多少人？
\end{itemize}

\subsection{除法原理}
\textbullet\ 除法原理
\begin{itemize}
    \item 如果一项任务可以用 $n$ 个方法完成，其中每个方法恰好对应（等价）于 $n$ 个方法中的 $d$ 个，那么完成这项任务的（不同）方法数是 $n/d$ 。
    \item 集合的视角：若一个有限集合 $S$ 可以划分为 $k$ 个不相交子集（等价类），且每个子集都恰好有 $d$ 个元素，那么子集的数量
    \[
    k = \frac{|S|}{d} = \frac{n}{d}
    \]
\end{itemize}

\textbullet\ 例20
\begin{itemize}
    \item 四个人围坐在一个圆桌，由多少种坐法？
    \item 每个人左右相邻的人都不变，就认为是同一种坐法
    \item 把座位标上顺序，则坐法有 $4! = 24$
    \item 有 4 种坐法对应于 1 种相同的左右相邻方式
    \item 所以不同的坐法数量为 $\frac{24}{4} = 6$ 种
\end{itemize}

\subsection{树图}
\textbullet\ 树图（Tree Diagram）
\begin{itemize}
    \item 分支：每个可能的选择
    \item 树叶：每个可能的结果
\end{itemize}

\textbullet\ 例22
\begin{itemize}
    \item 有多少不含连续两个 1 的 4 位比特串？
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{jishu4.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu5.png}
\end{figure}

\section{鸽巢原理}

\subsection{鸽巢原理}
\textbullet\ 鸽巢原理（Pigeonhole Principle）
\begin{itemize}
    \item 又称为抽屉原理，狄利克雷原理
    \item 把 $k + 1$ 个物体放入 $k$ 个盒子中，则至少有一个盒子中有 2 个或者更多的物体
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 用反证法。
    \item 假设 $k$ 个盒子中没有任何一个有超过 1 个物体，那么盒中物体的总数至多为 $k$ 个，与已知条件矛盾。
\end{itemize}
鸽巢原理只是指出了存在性，并没有指出是“哪个盒子”，也没有给出“那个盒子有几个物体”

\textbullet\ 鸽巢原理的不同形式
\begin{itemize}
    \item 集合形式：
    \begin{itemize}
        \item 把 $k + 1$ 个元素分为 $k$ 个集合 $A_1, A_2, \ldots , A_k$ ，则存在 $1 \leq i \leq k$ 使得 $|A_i| \geq 2$
    \end{itemize}
    \item 函数形式：
    \begin{itemize}
        \item 设 $A, B$ 为两个非空有限集合，元素个数分别为 $k + 1$ 和 $k$ ，$f: A \to B$ 为一个映射，则存在 $y \in B$ 使得 $|f^{-1}(y)| \geq 2$
        \item （推论1）如果 $A$ 的元素多于 $B$ 的元素，则函数 $f$ 不是单射（一对一）
    \end{itemize}
\end{itemize}

\textbullet\ 示例
\begin{itemize}
    \item 证明：一组 367 个人中至少存在 2 个人的生日相同
    \item 证明：一组 13 个人中至少存在 2 个人的生日在同一月份
    \item 从 $n$ 对夫妇随机选择一些人，为了保证能够至少有一对夫妇被选中，问至少要从这 $2n$ 个人中选出多少人？
    \item 利用鸽巢原理的关键：建立鸽巢，寻找鸽子
\end{itemize}

\textbullet\ 示例
\begin{itemize}
    \item 证明：任何一组人中都存在两个人，他们在组内认识的人一样多（认识是相互的，即如果 A 认识 B 则 B 也认识 A）
    \item 证明：把 5 个点放到边长为 2 的正方形中，至少存在 2 个点，它们之间的距离小于或等于 $\sqrt{2} $
\end{itemize}

\textbullet\ 例4
\begin{itemize}
    \item 对每一个整数 $n$ ，存在一个数是 $n$ 的倍数，其十进制表示中只出现 0 和 1
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 考虑 $n + 1$ 个整数 $1, 11, 111, \ldots , 11\ldots 1_n , 11\ldots 1_{n+1}$
    \item 将这 $n + 1$ 个整数除以 $n$ ，所得的余数只有 $n$ 种可能
    \item 根据鸽巢原理，必然有两个数除以 $n$ 的余数相同
    \item 这两个数的差能被 $n$ 整除，而且其十进制表示中只出现 0 和 1
\end{itemize}

\subsection{广义鸽巢原理}
\textbullet\ 广义鸽巢原理（Generalized Pigeonhole Principle）
\begin{itemize}
    \item 如果 $N$ 个物体放入 $k$ 个盒子，则至少有一个盒子里包含了至少 $\lceil \frac{N}{k} \rceil$ 个物体
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 用反证法。
    \item 假设 $k$ 个盒子中没有任何一个有超过 $\lceil \frac{N}{k} \rceil - 1$ 个物体，那么盒中物体的总数至多为 $k(\lceil \frac{N}{k} \rceil - 1) < k((\frac{N}{k}+1)-1) = N$ ，与已知条件矛盾。
\end{itemize}

\textbullet\ 广义鸽巢原理的不同形式
\begin{itemize}
    \item 集合形式：
    \begin{itemize}
        \item 把 $N$ 个元素分为 $k$ 个集合 $A_1, A_2, \ldots , A_k$ ，则存在 $1 \leq i \leq k$ 使得 $|A_i| \geq \lceil \frac{N}{k} \rceil$
    \end{itemize}
    \item 函数形式：
    \begin{itemize}
        \item 设 $A, B$ 为两个非空有限集合，$f: A \to B$ 为一个映射，则存在 $y \in B$ 使得 $|f^{-1}(y)| \geq \lceil \frac{|A|}{|B|} \rceil$
    \end{itemize}
\end{itemize}

\textbullet\ 推论
\begin{itemize}
    \item 把 $km + 1$ 个物体放入 $k$ 个盒子，则存在一个盒子至少含有 $m + 1$ 个物体。
\end{itemize}

\textbullet\ 定理
\begin{itemize}
    \item 令 $q_1, q_2, \ldots , q_n$ 为正整数，把 $q_1 + q_2 + \ldots + q_n - n + 1$ 个物体放入 $n$ 个盒子，那么存在 $1 \leq i \leq n$ 使得第 $i$ 个盒子至少含有 $q_i$ 个物体。
\end{itemize}

\textbullet\ 例6
\begin{itemize}
    \item 若有 5 个可能的成绩 $A, B, C, D, F$ ，那么在一个离散数学班里最少有多少个学生才能保证至少 6 个学生得到相同的分数？
\end{itemize}

\textbullet\ 例7
\begin{itemize}
    \item 从一副标准的 52 张牌中必须选多少张才能保证选出的牌中至少有 3 张是同样的花色？
    \item 必须选多少张才能保证选出的牌中至少有 3 张是红心？
    \item 必须选多少张才能保证选出的牌中至少有 3 张是同样的花色（红心或方块）？
\end{itemize}

\subsection{鸽巢原理的应用}
\textbullet\ 鸽巢原理有许多巧妙且优美的应用
\begin{itemize}
    \item 例10
    \begin{itemize}
        \item 在 30 天的某个月里，一支棒球队一天至少打 1 场比赛，但这个月至多打了 45 场。证明一定有连续的若干天内这支球队恰好打了 14 场比赛。
        \item 鸽巢？
        \item 鸽子？
    \end{itemize}
    \item 例11
    \begin{itemize}
        \item 证明：从不超过 $2n$ 的正整数中任选 $n + 1$ 个数，其中必然存在 2 个数，一个可以被另一个整除
        \item 任选 $n + 1$ 个正整数 $a_1, a_2, \ldots , a_n, a_{n+1}$ ，$1 \leq a_i \leq 2n$
        \item 每个 $a_i$ 都可以表示为 $a_i = 2^{k_i}q_i$ ，其中 $1 \leq q_i \leq 2n$ 是奇数
        \item 因为不超过 $2n$ 的奇数只有 $n$ 个，所以 $q_1, q_2, \ldots , q_{n+1}$ 必有两个相同
        \item 设相同的数为 $q_i = q_j = q$ ，则对应的数 $a_i = 2^{k_i}q, a_j = 2^{k_j}q$
        \item 当 $k_i \geq k_j$ 时 $a_i$ 可以被 $a_j$ 整除，当 $k_i \leq k_j$ 时 $a_j$ 可以被 $a_i$ 整除
    \end{itemize}
    \item Erdös定理
    \begin{itemize}
        \item 每个由 $n^2 + 1$ 个不同实数构成的序列 $a_1, a_2, \ldots , a_{n^2+1}$ ，一定含有长度为 $n + 1$ 的递增子序列或者递减子序列。
    \end{itemize}
    \item 例12
    \begin{itemize}
        \item 序列 8, 11, 9, 1, 4, 6, 12, 10, 5, 7
        \item $n = 3$
        \item 递增子序列： 1, 4, 6, 12 ，1, 4, 6, 10 ，1, 4, 6, 7 ，1, 4, 5, 7
        \item 递减子序列： 11, 9, 6, 5
    \end{itemize}
    \item 证明：
    \begin{itemize}
        \item 令 $a_1, a_2, \ldots , a_{n^2+1}$ 为不同实数构成的序列，令 $i_k, d_k$ 分别表示从 $a_k$ 开始的最长递增/减子序列长度
        \item 用反证法，假设 $\forall k = 1,2, \ldots , n^2 + 1, 1 \leq i_k, d_k \leq n$ ，则 $i_k, d_k$ 可能有 $n^2$ 种不同的取值（乘法原理）
        \item 根据鸽巢原理， $(i_1, d_1) , (i_2, d_2) , \ldots , (i_{n^2+1}, d_{n^2+1})$ 中必有两对是相同的，即存在 $1 \leq s < t \leq n^2 + 1$ 使得 $i_s = i_t, d_s = d_t$
        \item 如果 $a_s < a_t$ 那么将 $a_s$ 加到从 $a_t$ 开始的最长递增子序列之前，可以得到长度为 $i_t + 1$ 的递增子序列，即 $i_s \geq i_t + 1 > i_t$ ，矛盾
        \item 如果 $a_s > a_t$ ，同理可证 $d_s \geq d_t + 1 > d_t$ ，矛盾
    \end{itemize}
    \item 拉姆齐理论（Ramsey Theory）
    \begin{itemize}
        \item 图论与组合中的一个重要研究方向
        \item 研究集合元素的子集分配问题
    \end{itemize}
    \item 例13
    \begin{itemize}
        \item 在参加一个宴会的人群中，任何两个人之间要么相互认识，要么相互不认识，当参加人数大于或等于 6 时，必定存在 3 个人彼此都认识，或者 3 个人彼此都不认识。
    \end{itemize}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{jishu6.png}
    \end{figure}

    \item 例13
    \begin{itemize}
        \item 在 6 个人中，必定存在 3 个人彼此认识，或者 3 个人彼此不认识。
        \item 在 $K_6$ 中对边进行红蓝染色，则必定存在一个红色$K_3$ 或者一个蓝色$K_3$ 。
        \item 对于 6 个元素的集合 $A$ ，令 $S = \{x \mid x \subseteq A, |x| = 2\}$ 为 $A$ 上所有二元子集的集合。无论如何划分集合 $S$ 为两个子集 $S_1, S_2$ （即 $S_1 \cup S_2 = S, S_1 \cap S_2 = \emptyset$），集合 $A$ 中必定有 3 个元素，其所有的二元子集都属于 $S_1$ ，或者有 3 个元素，其所有的二元子集都属于 $S_2$ 。
    \end{itemize}
    \item 问题的扩展：
    \begin{itemize}
        \item 在 $K_9$ 中对边进行红蓝染色，则必定存在一个红色$K_4$ 或者一个蓝色$K_3$
        \item 在 $K_9$ 中对边进行红蓝染色，则必定存在一个红色$K_3$ 或者一个蓝色$K_4$
        \item 在 $K_{10}$ 中对边进行红蓝染色，则必定存在一个红色$K_4$ 或者一个蓝色$K_3$
        \item 在 $K_{18}$ 中对边进行红蓝染色，则必定存在一个红色$K_4$ 或者一个蓝色$K_4$
    \end{itemize}
    \item Ramsey问题
    \begin{itemize}
        \item 在足够大的人群中，是否一定能找到一群人相互认识或者相互不认识？
        \item 是否存在一个整数 $R(s,t)$ 使得 $\forall n \geq R(s,t)$ 在红蓝边染色的 $K_n$ 中必定存在红色$K_s$ 或者蓝色$K_t$ ?
    \end{itemize}
    \item 拉姆齐定理（Ramsey’s Theorem）
    \begin{itemize}
        \item 令 $s,t$ 为正整数，存在一个最小的正整数 $R(s,t)$ 使得对任意 $n \geq R(s,t)$ 和任意红蓝边染色，完全图 $K_n$ 中一定包含红色$K_s$ 或者蓝色$K_t$ 子图
    \end{itemize}
    \item 证明：
    \begin{itemize}
        \item 用数学归纳法证明 $R(s,t)$ 存在
        \item 显然 $R(n, 2) = R(2, n) = n$
        \item 假设 $R(s - 1,t)$ 和 $R(s,t - 1)$ 存在，可证 $R(s,t) \leq R(s - 1,t) + R(s,t - 1)$
        \item 令 $n = R(s - 1,t) + R(s,t - 1)$ ，考虑 $K_n$ ，从其中选择一个顶点 $v$
        \item 把剩余顶点划分为 $G_1 = \{w \mid \text{边}e(v, w) \text{为红色}\}$ 和 $G_2 = \{w \mid \text{边}e(v, w) \text{为蓝色}\}$
        \item 因为 $|G_1| + |G_2| + 1 = n = R(s - 1,t) + R(s,t - 1)$ ，所以必定有以下两种情况之一成立： $|G_1| \geq R(s - 1,t)$ 或 $|G_2| \geq R(s,t - 1)$
        \item 若 $|G_1| \geq R(s - 1,t)$ ，根据归纳假设，$G_1$ 包含红色$K_{s-1}$ 或蓝色$K_t$ ，则 $G_1 \cup \left\{v \right\}$ 包含红色$K_s$ 或蓝色$K_t$
        \item 若 $|G_2| \geq R(s,t - 1)$ ，同理可证 $G_2 \cup \left\{v\right\}$ 包含红色$K_s$ 或蓝色$K_t$
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{jishu7.png}
    \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{jishu8.png}
    \end{figure}
    \item Ramsey理论的意义
    \begin{itemize}
        \item 无序中包含有序：世界上完全的无序是不可能存在的，任一足够大的结构中必定包含有一个给定大小的规则子结构
        \item 如果要在组合学中举出一个而且仅一个精美的定理，大多数组合学家会提名Ramsey定理（Rota，1978）
        \item 如果强大的外星人入侵地球，向我们索取 $R(5,5)$ 的值，否则就毁灭地球，那么我们最好的策略是集中所有的计算机和数学家来求这个值。但如果外星人要问 $R(6,6)$ ，我们最好的选择也许是和外星人决战。（Paul Erdös）
    \end{itemize}
\end{itemize}

\section{排列与组合}
\subsection{排列与组合}
\textbullet\ 计数问题的类型
\begin{itemize}
    \item 排列（Permutation）：对元素的有序选择或摆放进行计数
    \begin{itemize}
        \item 没有重复
        \item 允许重复
    \end{itemize}
    \item 组合（Combination）：对元素的无序选择或摆放进行计数
    \begin{itemize}
        \item 没有重复
        \item 允许重复
    \end{itemize}
\end{itemize}

\subsection{排列}
\textbullet\ （无重）排列的定义
\begin{itemize}
    \item 令 $n$ 元集 $S = \{a_1, a_2, \ldots , a_n\}$
    \item 从 $S$ 中取出 $r$ 个不同元素按次序摆放，称为 $S$ 的一个 $r$-排列，其个数称为 $r$-排列数，记作 $P(n, r)$
    \item 当 $n = r$ 时，$S$ 的 $r$-排列又称为 $S$ 的（全）排列，其个数 $P(n, n)$ 称为（全）排列数
\end{itemize}

\textbullet\ 示例： $S = \{a, b, c\}$
\begin{itemize}
    \item $S$ 的 1-排列： $\{a, b, c\}$ $P(3,1) = 3$
    \item $S$ 的 2-排列： $\{ab, ac, ba, bc, ca, cb\}$ $P(3,2) = 6$
    \item $S$ 的 3-排列： $\{abc, acb, bac, bca, cab, cba\}$ $P(3,3) = 6$
\end{itemize}

\textbullet\ 定理1
\begin{itemize}
    \item 对于正整数 $n$ 和 $r \leq n$ ，有 $n$ 个不同元素的集合的 $r$-排列数为
    \[
    P(n, r) = n (n - 1) (n - 2) \cdots (n - r + 1)
    \]
\end{itemize}

\textbullet\ 推论1
\begin{itemize}
    \item $P(n, r) = \frac{n!}{(n-r)!}$
\end{itemize}

\textbullet\ 推论2
\begin{itemize}
    \item 若 $n, r \in \mathbb{N}$ 且 $n \geq r \geq 2$ ，则 $P(n, r) = n \cdot P(n - 1, r - 1)$
\end{itemize}

\textbullet\ 推论3
\begin{itemize}
    \item 若 $n, r \in \mathbb{N}$ 且 $n \geq r \geq 2$ ，则 $P(n, r) = r \cdot P(n - 1, r - 1) + P(n - 1, r)$
\end{itemize}

\textbullet\ 例1
\begin{itemize}
    \item 从 5 个学生中选出 3 个学生站成一行照相，有多少种不同的排法？
    \item 让 5 个学生站成一行照相，有多少种不同的排法？
\end{itemize}

\textbullet\ 例7
\begin{itemize}
    \item 字母 ABCDEFGH 有多少种排列包含字符串 ABC ？
\end{itemize}

\textbullet\ 练习：
\begin{itemize}
    \item 将 9 个字母的单词 FRAGMENTS 进行重排，要求字母 A 总是紧跟在字母 R 的右边，有多少种排法？
    \item 如果再要求字母 M 和 N 必须相邻，有多少种排法？
    \item 将 26 个英文字母进行排列，要求 5 个元音字母中任意两个都不能连续出现，一共有多少种符合要求的排法？
    \item 用 1, 2, \ldots , 9 可以组成多少个各位数字都不相同的 7 位数，而且 5 和 6 不能相邻？
\end{itemize}

\textbullet\ 练习：
\begin{itemize}
    \item 在 5 位数中，至少出现一个 6 而且能被 3 整除的数有多少个
\end{itemize}

\textbullet\ 排列的类型
\begin{itemize}
    \item 线排列：对象排成一条线
    \item 圆排列（循环排列） ：对象排成一个圆
    \item 可重排列
    \item 项链排列
\end{itemize}

\textbullet\ 循环排列（Circular Permutation）
\begin{itemize}
    \item 从集合 $S$ 的 $n$ 个元素中选出 $r$ 个，将它们排成一个圆圈（考虑顺序），称为一个循环 $r$-排列（圆排列）
\end{itemize}

\textbullet\ 定理
\begin{itemize}
    \item 有 $n$ 个元素的集合的循环 $r$-排列数为
    \[
    \frac{P(n, r)}{r} = \frac{n!}{r (n - r)!}
    \]
\end{itemize}

\textbullet\ 示例：
\begin{itemize}
    \item 有 8 人围着圆桌就餐，问有多少种就座方式（不区分圆桌朝向）？
    \item 如果其中有 2 个人不愿意坐在一起，有多少种就座方式？
    \item 如果这 8 个人正好 4 男 4 女，要求男女交替就座，有多少种就座方式？
\end{itemize}

\textbullet\ 项链排列（Necklace Permutation）
\begin{itemize}
    \item 在圆排列的基础上，如果通过旋转、平移、翻转后一致的，认为是同一排列。
    \item 有 $n$ 个元素的集合的项链 $r$-排列数为
    \[
    \frac{P(n, r)}{2r} = \frac{n!}{2r (n - r)!}
    \]
\end{itemize}

\subsection{组合}
\textbullet\ （无重）组合的定义
\begin{itemize}
    \item 令 $n$ 元集 $S = \{a_1, a_2, \ldots , a_n\}$
    \item 从 $S$ 中无序选择出 $r$ 个不同元素作为 $S$ 的一个子集，称为 $S$ 的一个 $r$-组合，其个数称为 $r$-组合数，记作 $C(n, r)$ ，也记作 $\binom{n}{r}$ 并称为二项式系数
\end{itemize}

\textbullet\ 示例： $S = \{a, b, c, d\}$
\begin{itemize}
    \item $S$ 的 1-组合： $\{a , b , c , d\}$ $C(4,1) = 4$
    \item $S$ 的 2-组合： $\{a, b , a, c , a, d , b, c , b, d , c, d\}$ $C(4,2) = 6$
    \item $S$ 的 3-组合： $\{a, b, c , a, b, d , a, c, d , \{b, c, d\}\}$ $C(4,3) = 4$
\end{itemize}

\textbullet\ 定理2
\begin{itemize}
    \item 对于正整数 $n$ 和 $0 \leq r \leq n$ ，有 $n$ 个不同元素的集合的 $r$-组合数为
    \[
    C(n, r) = \frac{n!}{r! (n - r)!}
    \]
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 根据乘法原理，有 $P(n, r) = C(n, r) \cdot P(r, r)$
    \item 所以
    \[
    C(n, r) = \frac{P(n,r)}{P(r,r)} = \frac{n!}{(n-r)!} \cdot \frac{1}{r!} = \frac{n!}{r! (n-r)!}
    \]
\end{itemize}

\textbullet\ 推论2
\begin{itemize}
    \item 对于正整数 $n$ 和 $0 \leq r \leq n$ ，有 $C(n, r) = C(n, n - r)$
\end{itemize}

\textbullet\ 组合证明（Combinatorial Proof）
\begin{itemize}
    \item 一种证明恒等式的方法，不依赖于代数技巧，包括：
    \begin{itemize}
        \item 双计数证明（double counting proof）
        \begin{itemize}
            \item 使用计数论证来证明等式两侧是对同样的对象用不同的方式进行计数
        \end{itemize}
        \item 双射证明（bijective proof）
        \begin{itemize}
            \item 证明在等式两侧计数的对象集合之间存在一个双射函数
        \end{itemize}
    \end{itemize}
\end{itemize}

\textbullet\ 推论2
\begin{itemize}
    \item 对于正整数 $n$ 和 $0 \leq r \leq n$ ，有 $C(n, r) = C(n, n - r)$
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 双射证明： $f(A) = \overline{A} , \quad A,\overline{A} \subseteq S$
    \item 双计数证明：$C(n, r)$ 为从 $n$ 个元素的集合 $S$ 的 $r$ 元子集的个数，而每个 $r$ 元子集也可以通过指定不在其中的 $n - r$ 个元素来定义，因此 $r$ 元子集的个数等于 $C(n, n - r)$
\end{itemize}

\textbullet\ 例15
\begin{itemize}
    \item 学校计划成立一个离散数学教学委员会，需要 3 名数学系的老师和 4 名计算机系的老师，如果数学系一共有 9 位老师，计算机系一共有 11 位老师。那么这个委员会有多少种选择？
    \item 先选数学系老师，再选计算机系老师，分步完成应使用乘法原理
    \item 选数学系老师有 $C(9,3)$ 种方式，选计算机系老师有 $C(11,4)$ 种方式
    \item 所以一共有
    \[
    C(9,3) \cdot C(11,4) = \frac{9!}{3!(9-3)!} \cdot \frac{11!}{4!(11-4)!} = 84 \cdot 330 = 27720
    \]
\end{itemize}

\textbullet\ 练习
\begin{itemize}
    \item 有 5 本日文书，7 本英文书，10 本中文书，从中取 2 本不同文字的书，有多少种方案？如果取 2 本相同文字的书，有多少种方案？任取 2 本书，有多少种方案？
    \item 从 1-300 之间任取 3 个不同的整数，使得这 3 个数之和正好被 3 整除，共有几种方案？
\end{itemize}

\section{二项式系数与恒等式}
\subsection{二项式定理}
\textbullet\ 二项式（Binomial Expression）
\begin{itemize}
    \item 单项式是常数和变量的乘积，如 $x$ ，$3x^2y$
    \item 两个单项式的和称为二项式，如 $x + y$ ， $3x + 2y$
\end{itemize}

\textbullet\ 二项式系数（Binomial Coefficients）
\begin{itemize}
    \item 组合数 $\binom{n}{k}$ 出现在二项式的幂 $(x + y)^n$ 的展开式中作为系数，因此也称为二项式系数
    \[
    \binom{n}{k} =
    \begin{cases}
        0 & k > n \\
        1 & k = 0 \text{ 或者 } k = n \\
        \frac{n!}{k!(n-k)!} & 1 \leq k \leq n
    \end{cases}
    \]
\end{itemize}

\textbullet\ 二项式定理（Binomial Theorem）
\begin{itemize}
    \item 设 $x, y$ 为变量，$n$ 为非负整数，那么
    \[
    (x + y)^n = \sum_{j=0}^{n} \binom{n}{j} x^{n-j} y^j
    \]
    即
    \[
    (x + y)^n = \binom{n}{0} x^n + \binom{n}{1} x^{n-1} y + \cdots + \binom{n}{n-1} xy^{n-1} + \binom{n}{n} y^n
    \]
\end{itemize}

\textbullet\ 证明：组合证明

\textbullet\ 推论1
\begin{itemize}
    \item 设 $n$ 为非负整数，那么
    \[
    \sum_{k=0}^{n} \binom{n}{k} = 2^n
    \]
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 代数证明（利用二项式定理）
    \item 组合证明（子集计数）
\end{itemize}

\textbullet\ 推论2
\begin{itemize}
    \item 设 $n$ 为正整数，那么
    \[
    \sum_{k=0}^{n} (-1)^k \binom{n}{k} = 0
    \]
\end{itemize}

\textbullet\ 推论3
\begin{itemize}
    \item 设 $n$ 为非负整数，那么
    \[
    \sum_{k=0}^{n} 2^k \binom{n}{k} = 3^n
    \]
\end{itemize}

\subsection{帕斯卡恒等式}
\textbullet\ 帕斯卡恒等式（Pascal’s Identity）
\begin{itemize}
    \item 设 $n, k$ 为整数且 $n \geq k \geq 0$ ，那么
    \[
    \binom{n+1}{k} = \binom{n}{k-1} + \binom{n}{k}
    \]
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 代数证明（利用组合数公式）
    \item 组合证明（固定一个元素进行计数）
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu9.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu10.png}
\end{figure}

\textbullet\ 二项式系数的性质
\begin{itemize}
    \item 对称性
    \[
    \binom{n}{k} = \binom{n}{n - k}
    \]
    \item 递归关系
    \[
    \binom{n+1}{k} = \binom{n}{k-1} + \binom{n}{k}
    \]
    \item 单峰性
    \[
    \binom{n}{0} < \binom{n}{1} < \cdots < \binom{n}{\lfloor n/2 \rfloor} = \binom{n}{\lceil n/2 \rceil} > \cdots > \binom{n}{n-1} > \binom{n}{n}
    \]
\end{itemize}

\subsection{其他恒等式}
\textbullet\ Vandermonde恒等式
\begin{itemize}
    \item 设 $m, n, r$ 为非负整数，$r \leq m, r \leq n$ ，那么
    \[
    \binom{m+n}{r} = \sum_{k=0}^{r} \binom{m}{r-k} \binom{n}{k}
    \]
\end{itemize}

\textbullet\ 推论4
\begin{itemize}
    \item 如果 $n$ 是一个非负整数，那么
    \[
    \binom{2n}{n} = \sum_{k=0}^{n} \binom{n}{k}^2
    \]
\end{itemize}

\textbullet\ 定理4
\begin{itemize}
    \item 设 $n, r$ 为非负整数，$r \leq n$ ，那么
    \[
    \binom{n+1}{r+1} = \sum_{j=r}^{n} \binom{j}{r}
    \]
\end{itemize}

\textbullet\ 证明：
\begin{itemize}
    \item 代数证明（利用帕斯卡恒等式）
    \item 组合证明
\end{itemize}

\subsection{二项式定理的推广}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu11.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jishu12.png}
\end{figure}


\end{document}